// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v3/clairpb/clair.proto

package clairpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import types "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Vulnerability struct {
	// The name of the vulnerability.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The name of the namespace in which the vulnerability was detected.
	NamespaceName string `protobuf:"bytes,2,opt,name=namespace_name,json=namespaceName,proto3" json:"namespace_name,omitempty"`
	// A description of the vulnerability according to the source for the namespace.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// A link to the vulnerability according to the source for the namespace.
	Link string `protobuf:"bytes,4,opt,name=link,proto3" json:"link,omitempty"`
	// How dangerous the vulnerability is.
	Severity string `protobuf:"bytes,5,opt,name=severity,proto3" json:"severity,omitempty"`
	// Namespace agnostic metadata about the vulnerability.
	Metadata string `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The feature that fixes this vulnerability.
	// This field only exists when a vulnerability is a part of a Feature.
	FixedBy string `protobuf:"bytes,7,opt,name=fixed_by,json=fixedBy,proto3" json:"fixed_by,omitempty"`
	// The Features that are affected by the vulnerability.
	// This field only exists when a vulnerability is a part of a Notification.
	AffectedVersions     []*Feature `protobuf:"bytes,8,rep,name=affected_versions,json=affectedVersions" json:"affected_versions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Vulnerability) Reset()      { *m = Vulnerability{} }
func (*Vulnerability) ProtoMessage() {}
func (*Vulnerability) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{0}
}
func (m *Vulnerability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vulnerability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vulnerability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Vulnerability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vulnerability.Merge(dst, src)
}
func (m *Vulnerability) XXX_Size() int {
	return m.Size()
}
func (m *Vulnerability) XXX_DiscardUnknown() {
	xxx_messageInfo_Vulnerability.DiscardUnknown(m)
}

var xxx_messageInfo_Vulnerability proto.InternalMessageInfo

func (m *Vulnerability) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Vulnerability) GetNamespaceName() string {
	if m != nil {
		return m.NamespaceName
	}
	return ""
}

func (m *Vulnerability) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Vulnerability) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Vulnerability) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *Vulnerability) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Vulnerability) GetFixedBy() string {
	if m != nil {
		return m.FixedBy
	}
	return ""
}

func (m *Vulnerability) GetAffectedVersions() []*Feature {
	if m != nil {
		return m.AffectedVersions
	}
	return nil
}

type Feature struct {
	// The name of the feature.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The name of the namespace in which the feature is detected.
	NamespaceName string `protobuf:"bytes,2,opt,name=namespace_name,json=namespaceName,proto3" json:"namespace_name,omitempty"`
	// The specific version of this feature.
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// The format used to parse version numbers for the feature.
	VersionFormat string `protobuf:"bytes,4,opt,name=version_format,json=versionFormat,proto3" json:"version_format,omitempty"`
	// The list of vulnerabilities that affect the feature.
	Vulnerabilities      []*Vulnerability `protobuf:"bytes,5,rep,name=vulnerabilities" json:"vulnerabilities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Feature) Reset()      { *m = Feature{} }
func (*Feature) ProtoMessage() {}
func (*Feature) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{1}
}
func (m *Feature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Feature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Feature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Feature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Feature.Merge(dst, src)
}
func (m *Feature) XXX_Size() int {
	return m.Size()
}
func (m *Feature) XXX_DiscardUnknown() {
	xxx_messageInfo_Feature.DiscardUnknown(m)
}

var xxx_messageInfo_Feature proto.InternalMessageInfo

func (m *Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Feature) GetNamespaceName() string {
	if m != nil {
		return m.NamespaceName
	}
	return ""
}

func (m *Feature) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Feature) GetVersionFormat() string {
	if m != nil {
		return m.VersionFormat
	}
	return ""
}

func (m *Feature) GetVulnerabilities() []*Vulnerability {
	if m != nil {
		return m.Vulnerabilities
	}
	return nil
}

type Layer struct {
	// The sha256 tarsum for the layer.
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Layer) Reset()      { *m = Layer{} }
func (*Layer) ProtoMessage() {}
func (*Layer) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{2}
}
func (m *Layer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Layer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Layer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Layer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer.Merge(dst, src)
}
func (m *Layer) XXX_Size() int {
	return m.Size()
}
func (m *Layer) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer.DiscardUnknown(m)
}

var xxx_messageInfo_Layer proto.InternalMessageInfo

func (m *Layer) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type ClairStatus struct {
	// The configured list of feature listers used to scan an ancestry.
	Listers []string `protobuf:"bytes,1,rep,name=listers" json:"listers,omitempty"`
	// The configured list of namespace detectors used to scan an ancestry.
	Detectors []string `protobuf:"bytes,2,rep,name=detectors" json:"detectors,omitempty"`
	// The time at which the updater last ran.
	LastUpdateTime       *types.Timestamp `protobuf:"bytes,3,opt,name=last_update_time,json=lastUpdateTime" json:"last_update_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ClairStatus) Reset()      { *m = ClairStatus{} }
func (*ClairStatus) ProtoMessage() {}
func (*ClairStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{3}
}
func (m *ClairStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClairStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClairStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClairStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClairStatus.Merge(dst, src)
}
func (m *ClairStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClairStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClairStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClairStatus proto.InternalMessageInfo

func (m *ClairStatus) GetListers() []string {
	if m != nil {
		return m.Listers
	}
	return nil
}

func (m *ClairStatus) GetDetectors() []string {
	if m != nil {
		return m.Detectors
	}
	return nil
}

func (m *ClairStatus) GetLastUpdateTime() *types.Timestamp {
	if m != nil {
		return m.LastUpdateTime
	}
	return nil
}

type GetAncestryRequest struct {
	// The name of the desired ancestry.
	AncestryName string `protobuf:"bytes,1,opt,name=ancestry_name,json=ancestryName,proto3" json:"ancestry_name,omitempty"`
	// Whether to include vulnerabilities or not in the response.
	WithVulnerabilities bool `protobuf:"varint,2,opt,name=with_vulnerabilities,json=withVulnerabilities,proto3" json:"with_vulnerabilities,omitempty"`
	// Whether to include features or not in the response.
	WithFeatures         bool     `protobuf:"varint,3,opt,name=with_features,json=withFeatures,proto3" json:"with_features,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAncestryRequest) Reset()      { *m = GetAncestryRequest{} }
func (*GetAncestryRequest) ProtoMessage() {}
func (*GetAncestryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{4}
}
func (m *GetAncestryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAncestryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAncestryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAncestryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAncestryRequest.Merge(dst, src)
}
func (m *GetAncestryRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAncestryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAncestryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAncestryRequest proto.InternalMessageInfo

func (m *GetAncestryRequest) GetAncestryName() string {
	if m != nil {
		return m.AncestryName
	}
	return ""
}

func (m *GetAncestryRequest) GetWithVulnerabilities() bool {
	if m != nil {
		return m.WithVulnerabilities
	}
	return false
}

func (m *GetAncestryRequest) GetWithFeatures() bool {
	if m != nil {
		return m.WithFeatures
	}
	return false
}

type GetAncestryResponse struct {
	// The ancestry requested.
	Ancestry *GetAncestryResponse_Ancestry `protobuf:"bytes,1,opt,name=ancestry" json:"ancestry,omitempty"`
	// The status of Clair at the time of the request.
	Status               *ClairStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetAncestryResponse) Reset()      { *m = GetAncestryResponse{} }
func (*GetAncestryResponse) ProtoMessage() {}
func (*GetAncestryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{5}
}
func (m *GetAncestryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAncestryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAncestryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAncestryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAncestryResponse.Merge(dst, src)
}
func (m *GetAncestryResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAncestryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAncestryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAncestryResponse proto.InternalMessageInfo

func (m *GetAncestryResponse) GetAncestry() *GetAncestryResponse_Ancestry {
	if m != nil {
		return m.Ancestry
	}
	return nil
}

func (m *GetAncestryResponse) GetStatus() *ClairStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type GetAncestryResponse_Ancestry struct {
	// The name of the desired ancestry.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The list of features present in the ancestry.
	// This will only be provided if requested.
	Features []*Feature `protobuf:"bytes,2,rep,name=features" json:"features,omitempty"`
	// The layers present in the ancestry.
	Layers []*Layer `protobuf:"bytes,3,rep,name=layers" json:"layers,omitempty"`
	// The configured list of feature listers used to scan this ancestry.
	ScannedListers []string `protobuf:"bytes,4,rep,name=scanned_listers,json=scannedListers" json:"scanned_listers,omitempty"`
	// The configured list of namespace detectors used to scan an ancestry.
	ScannedDetectors     []string `protobuf:"bytes,5,rep,name=scanned_detectors,json=scannedDetectors" json:"scanned_detectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAncestryResponse_Ancestry) Reset()      { *m = GetAncestryResponse_Ancestry{} }
func (*GetAncestryResponse_Ancestry) ProtoMessage() {}
func (*GetAncestryResponse_Ancestry) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{5, 0}
}
func (m *GetAncestryResponse_Ancestry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAncestryResponse_Ancestry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAncestryResponse_Ancestry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAncestryResponse_Ancestry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAncestryResponse_Ancestry.Merge(dst, src)
}
func (m *GetAncestryResponse_Ancestry) XXX_Size() int {
	return m.Size()
}
func (m *GetAncestryResponse_Ancestry) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAncestryResponse_Ancestry.DiscardUnknown(m)
}

var xxx_messageInfo_GetAncestryResponse_Ancestry proto.InternalMessageInfo

func (m *GetAncestryResponse_Ancestry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetAncestryResponse_Ancestry) GetFeatures() []*Feature {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *GetAncestryResponse_Ancestry) GetLayers() []*Layer {
	if m != nil {
		return m.Layers
	}
	return nil
}

func (m *GetAncestryResponse_Ancestry) GetScannedListers() []string {
	if m != nil {
		return m.ScannedListers
	}
	return nil
}

func (m *GetAncestryResponse_Ancestry) GetScannedDetectors() []string {
	if m != nil {
		return m.ScannedDetectors
	}
	return nil
}

type PostAncestryRequest struct {
	// The name of the ancestry being scanned.
	// If scanning OCI images, this should be the hash of the manifest.
	AncestryName string `protobuf:"bytes,1,opt,name=ancestry_name,json=ancestryName,proto3" json:"ancestry_name,omitempty"`
	// The format of the image being uploaded.
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	// The layers to be scanned for this particular ancestry.
	Layers               []*PostAncestryRequest_PostLayer `protobuf:"bytes,3,rep,name=layers" json:"layers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *PostAncestryRequest) Reset()      { *m = PostAncestryRequest{} }
func (*PostAncestryRequest) ProtoMessage() {}
func (*PostAncestryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{6}
}
func (m *PostAncestryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostAncestryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostAncestryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PostAncestryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostAncestryRequest.Merge(dst, src)
}
func (m *PostAncestryRequest) XXX_Size() int {
	return m.Size()
}
func (m *PostAncestryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PostAncestryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PostAncestryRequest proto.InternalMessageInfo

func (m *PostAncestryRequest) GetAncestryName() string {
	if m != nil {
		return m.AncestryName
	}
	return ""
}

func (m *PostAncestryRequest) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *PostAncestryRequest) GetLayers() []*PostAncestryRequest_PostLayer {
	if m != nil {
		return m.Layers
	}
	return nil
}

type PostAncestryRequest_PostLayer struct {
	// The hash of the layer.
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// The location of the layer (URL or filepath).
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Any HTTP Headers that need to be used if requesting a layer over HTTP(S).
	Headers              map[string]string `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PostAncestryRequest_PostLayer) Reset()      { *m = PostAncestryRequest_PostLayer{} }
func (*PostAncestryRequest_PostLayer) ProtoMessage() {}
func (*PostAncestryRequest_PostLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{6, 0}
}
func (m *PostAncestryRequest_PostLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostAncestryRequest_PostLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostAncestryRequest_PostLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PostAncestryRequest_PostLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostAncestryRequest_PostLayer.Merge(dst, src)
}
func (m *PostAncestryRequest_PostLayer) XXX_Size() int {
	return m.Size()
}
func (m *PostAncestryRequest_PostLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_PostAncestryRequest_PostLayer.DiscardUnknown(m)
}

var xxx_messageInfo_PostAncestryRequest_PostLayer proto.InternalMessageInfo

func (m *PostAncestryRequest_PostLayer) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *PostAncestryRequest_PostLayer) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *PostAncestryRequest_PostLayer) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type PostAncestryResponse struct {
	// The status of Clair at the time of the request.
	Status               *ClairStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PostAncestryResponse) Reset()      { *m = PostAncestryResponse{} }
func (*PostAncestryResponse) ProtoMessage() {}
func (*PostAncestryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{7}
}
func (m *PostAncestryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostAncestryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostAncestryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PostAncestryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostAncestryResponse.Merge(dst, src)
}
func (m *PostAncestryResponse) XXX_Size() int {
	return m.Size()
}
func (m *PostAncestryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PostAncestryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PostAncestryResponse proto.InternalMessageInfo

func (m *PostAncestryResponse) GetStatus() *ClairStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type GetNotificationRequest struct {
	// The current page of previous vulnerabilities for the ancestry.
	// This will be empty when it is the first page.
	OldVulnerabilityPage string `protobuf:"bytes,1,opt,name=old_vulnerability_page,json=oldVulnerabilityPage,proto3" json:"old_vulnerability_page,omitempty"`
	// The current page of vulnerabilities for the ancestry.
	// This will be empty when it is the first page.
	NewVulnerabilityPage string `protobuf:"bytes,2,opt,name=new_vulnerability_page,json=newVulnerabilityPage,proto3" json:"new_vulnerability_page,omitempty"`
	// The requested maximum number of results per page.
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// The name of the notification being requested.
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNotificationRequest) Reset()      { *m = GetNotificationRequest{} }
func (*GetNotificationRequest) ProtoMessage() {}
func (*GetNotificationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{8}
}
func (m *GetNotificationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNotificationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNotificationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetNotificationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNotificationRequest.Merge(dst, src)
}
func (m *GetNotificationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetNotificationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNotificationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetNotificationRequest proto.InternalMessageInfo

func (m *GetNotificationRequest) GetOldVulnerabilityPage() string {
	if m != nil {
		return m.OldVulnerabilityPage
	}
	return ""
}

func (m *GetNotificationRequest) GetNewVulnerabilityPage() string {
	if m != nil {
		return m.NewVulnerabilityPage
	}
	return ""
}

func (m *GetNotificationRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetNotificationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetNotificationResponse struct {
	// The notification as requested.
	Notification         *GetNotificationResponse_Notification `protobuf:"bytes,1,opt,name=notification" json:"notification,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *GetNotificationResponse) Reset()      { *m = GetNotificationResponse{} }
func (*GetNotificationResponse) ProtoMessage() {}
func (*GetNotificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{9}
}
func (m *GetNotificationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNotificationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNotificationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetNotificationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNotificationResponse.Merge(dst, src)
}
func (m *GetNotificationResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetNotificationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNotificationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetNotificationResponse proto.InternalMessageInfo

func (m *GetNotificationResponse) GetNotification() *GetNotificationResponse_Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

type GetNotificationResponse_Notification struct {
	// The name of the requested notification.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The time at which the notification was created.
	Created string `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// The time at which the notification was last sent out.
	Notified string `protobuf:"bytes,3,opt,name=notified,proto3" json:"notified,omitempty"`
	// The time at which a notification has been deleted.
	Deleted string `protobuf:"bytes,4,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// The previous vulnerability and a paginated view of the ancestries it affects.
	Old *PagedVulnerableAncestries `protobuf:"bytes,5,opt,name=old" json:"old,omitempty"`
	// The newly updated vulnerability and a paginated view of the ancestries it affects.
	New                  *PagedVulnerableAncestries `protobuf:"bytes,6,opt,name=new" json:"new,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *GetNotificationResponse_Notification) Reset()      { *m = GetNotificationResponse_Notification{} }
func (*GetNotificationResponse_Notification) ProtoMessage() {}
func (*GetNotificationResponse_Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{9, 0}
}
func (m *GetNotificationResponse_Notification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNotificationResponse_Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNotificationResponse_Notification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetNotificationResponse_Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNotificationResponse_Notification.Merge(dst, src)
}
func (m *GetNotificationResponse_Notification) XXX_Size() int {
	return m.Size()
}
func (m *GetNotificationResponse_Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNotificationResponse_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_GetNotificationResponse_Notification proto.InternalMessageInfo

func (m *GetNotificationResponse_Notification) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetNotificationResponse_Notification) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *GetNotificationResponse_Notification) GetNotified() string {
	if m != nil {
		return m.Notified
	}
	return ""
}

func (m *GetNotificationResponse_Notification) GetDeleted() string {
	if m != nil {
		return m.Deleted
	}
	return ""
}

func (m *GetNotificationResponse_Notification) GetOld() *PagedVulnerableAncestries {
	if m != nil {
		return m.Old
	}
	return nil
}

func (m *GetNotificationResponse_Notification) GetNew() *PagedVulnerableAncestries {
	if m != nil {
		return m.New
	}
	return nil
}

type PagedVulnerableAncestries struct {
	// The identifier for the current page.
	CurrentPage string `protobuf:"bytes,1,opt,name=current_page,json=currentPage,proto3" json:"current_page,omitempty"`
	// The token used to request the next page.
	// This will be empty when there are no more pages.
	NextPage string `protobuf:"bytes,2,opt,name=next_page,json=nextPage,proto3" json:"next_page,omitempty"`
	// The requested maximum number of results per page.
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// The vulnerability that affects a given set of ancestries.
	Vulnerability *Vulnerability `protobuf:"bytes,4,opt,name=vulnerability" json:"vulnerability,omitempty"`
	// The ancestries affected by a vulnerability.
	Ancestries           []*PagedVulnerableAncestries_IndexedAncestryName `protobuf:"bytes,5,rep,name=ancestries" json:"ancestries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *PagedVulnerableAncestries) Reset()      { *m = PagedVulnerableAncestries{} }
func (*PagedVulnerableAncestries) ProtoMessage() {}
func (*PagedVulnerableAncestries) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{10}
}
func (m *PagedVulnerableAncestries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PagedVulnerableAncestries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PagedVulnerableAncestries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PagedVulnerableAncestries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PagedVulnerableAncestries.Merge(dst, src)
}
func (m *PagedVulnerableAncestries) XXX_Size() int {
	return m.Size()
}
func (m *PagedVulnerableAncestries) XXX_DiscardUnknown() {
	xxx_messageInfo_PagedVulnerableAncestries.DiscardUnknown(m)
}

var xxx_messageInfo_PagedVulnerableAncestries proto.InternalMessageInfo

func (m *PagedVulnerableAncestries) GetCurrentPage() string {
	if m != nil {
		return m.CurrentPage
	}
	return ""
}

func (m *PagedVulnerableAncestries) GetNextPage() string {
	if m != nil {
		return m.NextPage
	}
	return ""
}

func (m *PagedVulnerableAncestries) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PagedVulnerableAncestries) GetVulnerability() *Vulnerability {
	if m != nil {
		return m.Vulnerability
	}
	return nil
}

func (m *PagedVulnerableAncestries) GetAncestries() []*PagedVulnerableAncestries_IndexedAncestryName {
	if m != nil {
		return m.Ancestries
	}
	return nil
}

type PagedVulnerableAncestries_IndexedAncestryName struct {
	// The index is an ever increasing number associated with the particular ancestry.
	// This is useful if you're processing notifications, and need to keep track of the progress of paginating the results.
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The name of the ancestry.
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PagedVulnerableAncestries_IndexedAncestryName) Reset() {
	*m = PagedVulnerableAncestries_IndexedAncestryName{}
}
func (*PagedVulnerableAncestries_IndexedAncestryName) ProtoMessage() {}
func (*PagedVulnerableAncestries_IndexedAncestryName) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{10, 0}
}
func (m *PagedVulnerableAncestries_IndexedAncestryName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PagedVulnerableAncestries_IndexedAncestryName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PagedVulnerableAncestries_IndexedAncestryName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PagedVulnerableAncestries_IndexedAncestryName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PagedVulnerableAncestries_IndexedAncestryName.Merge(dst, src)
}
func (m *PagedVulnerableAncestries_IndexedAncestryName) XXX_Size() int {
	return m.Size()
}
func (m *PagedVulnerableAncestries_IndexedAncestryName) XXX_DiscardUnknown() {
	xxx_messageInfo_PagedVulnerableAncestries_IndexedAncestryName.DiscardUnknown(m)
}

var xxx_messageInfo_PagedVulnerableAncestries_IndexedAncestryName proto.InternalMessageInfo

func (m *PagedVulnerableAncestries_IndexedAncestryName) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PagedVulnerableAncestries_IndexedAncestryName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MarkNotificationAsReadRequest struct {
	// The name of the Notification that has been processed.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkNotificationAsReadRequest) Reset()      { *m = MarkNotificationAsReadRequest{} }
func (*MarkNotificationAsReadRequest) ProtoMessage() {}
func (*MarkNotificationAsReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{11}
}
func (m *MarkNotificationAsReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkNotificationAsReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkNotificationAsReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkNotificationAsReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkNotificationAsReadRequest.Merge(dst, src)
}
func (m *MarkNotificationAsReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkNotificationAsReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkNotificationAsReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkNotificationAsReadRequest proto.InternalMessageInfo

func (m *MarkNotificationAsReadRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MarkNotificationAsReadResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkNotificationAsReadResponse) Reset()      { *m = MarkNotificationAsReadResponse{} }
func (*MarkNotificationAsReadResponse) ProtoMessage() {}
func (*MarkNotificationAsReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_clair_9de75ee587b4d16c, []int{12}
}
func (m *MarkNotificationAsReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkNotificationAsReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkNotificationAsReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkNotificationAsReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkNotificationAsReadResponse.Merge(dst, src)
}
func (m *MarkNotificationAsReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkNotificationAsReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkNotificationAsReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkNotificationAsReadResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Vulnerability)(nil), "coreos.clair.Vulnerability")
	proto.RegisterType((*Feature)(nil), "coreos.clair.Feature")
	proto.RegisterType((*Layer)(nil), "coreos.clair.Layer")
	proto.RegisterType((*ClairStatus)(nil), "coreos.clair.ClairStatus")
	proto.RegisterType((*GetAncestryRequest)(nil), "coreos.clair.GetAncestryRequest")
	proto.RegisterType((*GetAncestryResponse)(nil), "coreos.clair.GetAncestryResponse")
	proto.RegisterType((*GetAncestryResponse_Ancestry)(nil), "coreos.clair.GetAncestryResponse.Ancestry")
	proto.RegisterType((*PostAncestryRequest)(nil), "coreos.clair.PostAncestryRequest")
	proto.RegisterType((*PostAncestryRequest_PostLayer)(nil), "coreos.clair.PostAncestryRequest.PostLayer")
	proto.RegisterMapType((map[string]string)(nil), "coreos.clair.PostAncestryRequest.PostLayer.HeadersEntry")
	proto.RegisterType((*PostAncestryResponse)(nil), "coreos.clair.PostAncestryResponse")
	proto.RegisterType((*GetNotificationRequest)(nil), "coreos.clair.GetNotificationRequest")
	proto.RegisterType((*GetNotificationResponse)(nil), "coreos.clair.GetNotificationResponse")
	proto.RegisterType((*GetNotificationResponse_Notification)(nil), "coreos.clair.GetNotificationResponse.Notification")
	proto.RegisterType((*PagedVulnerableAncestries)(nil), "coreos.clair.PagedVulnerableAncestries")
	proto.RegisterType((*PagedVulnerableAncestries_IndexedAncestryName)(nil), "coreos.clair.PagedVulnerableAncestries.IndexedAncestryName")
	proto.RegisterType((*MarkNotificationAsReadRequest)(nil), "coreos.clair.MarkNotificationAsReadRequest")
	proto.RegisterType((*MarkNotificationAsReadResponse)(nil), "coreos.clair.MarkNotificationAsReadResponse")
}
func (this *Vulnerability) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vulnerability)
	if !ok {
		that2, ok := that.(Vulnerability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.NamespaceName != that1.NamespaceName {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Link != that1.Link {
		return false
	}
	if this.Severity != that1.Severity {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if this.FixedBy != that1.FixedBy {
		return false
	}
	if len(this.AffectedVersions) != len(that1.AffectedVersions) {
		return false
	}
	for i := range this.AffectedVersions {
		if !this.AffectedVersions[i].Equal(that1.AffectedVersions[i]) {
			return false
		}
	}
	return true
}
func (this *Feature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Feature)
	if !ok {
		that2, ok := that.(Feature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.NamespaceName != that1.NamespaceName {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.VersionFormat != that1.VersionFormat {
		return false
	}
	if len(this.Vulnerabilities) != len(that1.Vulnerabilities) {
		return false
	}
	for i := range this.Vulnerabilities {
		if !this.Vulnerabilities[i].Equal(that1.Vulnerabilities[i]) {
			return false
		}
	}
	return true
}
func (this *Layer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer)
	if !ok {
		that2, ok := that.(Layer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	return true
}
func (this *ClairStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClairStatus)
	if !ok {
		that2, ok := that.(ClairStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Listers) != len(that1.Listers) {
		return false
	}
	for i := range this.Listers {
		if this.Listers[i] != that1.Listers[i] {
			return false
		}
	}
	if len(this.Detectors) != len(that1.Detectors) {
		return false
	}
	for i := range this.Detectors {
		if this.Detectors[i] != that1.Detectors[i] {
			return false
		}
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	return true
}
func (this *GetAncestryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAncestryRequest)
	if !ok {
		that2, ok := that.(GetAncestryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AncestryName != that1.AncestryName {
		return false
	}
	if this.WithVulnerabilities != that1.WithVulnerabilities {
		return false
	}
	if this.WithFeatures != that1.WithFeatures {
		return false
	}
	return true
}
func (this *GetAncestryResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAncestryResponse)
	if !ok {
		that2, ok := that.(GetAncestryResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ancestry.Equal(that1.Ancestry) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *GetAncestryResponse_Ancestry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAncestryResponse_Ancestry)
	if !ok {
		that2, ok := that.(GetAncestryResponse_Ancestry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Features) != len(that1.Features) {
		return false
	}
	for i := range this.Features {
		if !this.Features[i].Equal(that1.Features[i]) {
			return false
		}
	}
	if len(this.Layers) != len(that1.Layers) {
		return false
	}
	for i := range this.Layers {
		if !this.Layers[i].Equal(that1.Layers[i]) {
			return false
		}
	}
	if len(this.ScannedListers) != len(that1.ScannedListers) {
		return false
	}
	for i := range this.ScannedListers {
		if this.ScannedListers[i] != that1.ScannedListers[i] {
			return false
		}
	}
	if len(this.ScannedDetectors) != len(that1.ScannedDetectors) {
		return false
	}
	for i := range this.ScannedDetectors {
		if this.ScannedDetectors[i] != that1.ScannedDetectors[i] {
			return false
		}
	}
	return true
}
func (this *PostAncestryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostAncestryRequest)
	if !ok {
		that2, ok := that.(PostAncestryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AncestryName != that1.AncestryName {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	if len(this.Layers) != len(that1.Layers) {
		return false
	}
	for i := range this.Layers {
		if !this.Layers[i].Equal(that1.Layers[i]) {
			return false
		}
	}
	return true
}
func (this *PostAncestryRequest_PostLayer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostAncestryRequest_PostLayer)
	if !ok {
		that2, ok := that.(PostAncestryRequest_PostLayer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if this.Headers[i] != that1.Headers[i] {
			return false
		}
	}
	return true
}
func (this *PostAncestryResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostAncestryResponse)
	if !ok {
		that2, ok := that.(PostAncestryResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *GetNotificationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetNotificationRequest)
	if !ok {
		that2, ok := that.(GetNotificationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OldVulnerabilityPage != that1.OldVulnerabilityPage {
		return false
	}
	if this.NewVulnerabilityPage != that1.NewVulnerabilityPage {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GetNotificationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetNotificationResponse)
	if !ok {
		that2, ok := that.(GetNotificationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Notification.Equal(that1.Notification) {
		return false
	}
	return true
}
func (this *GetNotificationResponse_Notification) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetNotificationResponse_Notification)
	if !ok {
		that2, ok := that.(GetNotificationResponse_Notification)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Created != that1.Created {
		return false
	}
	if this.Notified != that1.Notified {
		return false
	}
	if this.Deleted != that1.Deleted {
		return false
	}
	if !this.Old.Equal(that1.Old) {
		return false
	}
	if !this.New.Equal(that1.New) {
		return false
	}
	return true
}
func (this *PagedVulnerableAncestries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PagedVulnerableAncestries)
	if !ok {
		that2, ok := that.(PagedVulnerableAncestries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CurrentPage != that1.CurrentPage {
		return false
	}
	if this.NextPage != that1.NextPage {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.Vulnerability.Equal(that1.Vulnerability) {
		return false
	}
	if len(this.Ancestries) != len(that1.Ancestries) {
		return false
	}
	for i := range this.Ancestries {
		if !this.Ancestries[i].Equal(that1.Ancestries[i]) {
			return false
		}
	}
	return true
}
func (this *PagedVulnerableAncestries_IndexedAncestryName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PagedVulnerableAncestries_IndexedAncestryName)
	if !ok {
		that2, ok := that.(PagedVulnerableAncestries_IndexedAncestryName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MarkNotificationAsReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MarkNotificationAsReadRequest)
	if !ok {
		that2, ok := that.(MarkNotificationAsReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MarkNotificationAsReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MarkNotificationAsReadResponse)
	if !ok {
		that2, ok := that.(MarkNotificationAsReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Vulnerability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&clairpb.Vulnerability{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "NamespaceName: "+fmt.Sprintf("%#v", this.NamespaceName)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Link: "+fmt.Sprintf("%#v", this.Link)+",\n")
	s = append(s, "Severity: "+fmt.Sprintf("%#v", this.Severity)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "FixedBy: "+fmt.Sprintf("%#v", this.FixedBy)+",\n")
	if this.AffectedVersions != nil {
		s = append(s, "AffectedVersions: "+fmt.Sprintf("%#v", this.AffectedVersions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Feature) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&clairpb.Feature{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "NamespaceName: "+fmt.Sprintf("%#v", this.NamespaceName)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "VersionFormat: "+fmt.Sprintf("%#v", this.VersionFormat)+",\n")
	if this.Vulnerabilities != nil {
		s = append(s, "Vulnerabilities: "+fmt.Sprintf("%#v", this.Vulnerabilities)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Layer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&clairpb.Layer{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClairStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&clairpb.ClairStatus{")
	s = append(s, "Listers: "+fmt.Sprintf("%#v", this.Listers)+",\n")
	s = append(s, "Detectors: "+fmt.Sprintf("%#v", this.Detectors)+",\n")
	if this.LastUpdateTime != nil {
		s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAncestryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&clairpb.GetAncestryRequest{")
	s = append(s, "AncestryName: "+fmt.Sprintf("%#v", this.AncestryName)+",\n")
	s = append(s, "WithVulnerabilities: "+fmt.Sprintf("%#v", this.WithVulnerabilities)+",\n")
	s = append(s, "WithFeatures: "+fmt.Sprintf("%#v", this.WithFeatures)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAncestryResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&clairpb.GetAncestryResponse{")
	if this.Ancestry != nil {
		s = append(s, "Ancestry: "+fmt.Sprintf("%#v", this.Ancestry)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAncestryResponse_Ancestry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&clairpb.GetAncestryResponse_Ancestry{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Features != nil {
		s = append(s, "Features: "+fmt.Sprintf("%#v", this.Features)+",\n")
	}
	if this.Layers != nil {
		s = append(s, "Layers: "+fmt.Sprintf("%#v", this.Layers)+",\n")
	}
	s = append(s, "ScannedListers: "+fmt.Sprintf("%#v", this.ScannedListers)+",\n")
	s = append(s, "ScannedDetectors: "+fmt.Sprintf("%#v", this.ScannedDetectors)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PostAncestryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&clairpb.PostAncestryRequest{")
	s = append(s, "AncestryName: "+fmt.Sprintf("%#v", this.AncestryName)+",\n")
	s = append(s, "Format: "+fmt.Sprintf("%#v", this.Format)+",\n")
	if this.Layers != nil {
		s = append(s, "Layers: "+fmt.Sprintf("%#v", this.Layers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PostAncestryRequest_PostLayer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&clairpb.PostAncestryRequest_PostLayer{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]string{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%#v: %#v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	if this.Headers != nil {
		s = append(s, "Headers: "+mapStringForHeaders+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PostAncestryResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&clairpb.PostAncestryResponse{")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetNotificationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&clairpb.GetNotificationRequest{")
	s = append(s, "OldVulnerabilityPage: "+fmt.Sprintf("%#v", this.OldVulnerabilityPage)+",\n")
	s = append(s, "NewVulnerabilityPage: "+fmt.Sprintf("%#v", this.NewVulnerabilityPage)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetNotificationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&clairpb.GetNotificationResponse{")
	if this.Notification != nil {
		s = append(s, "Notification: "+fmt.Sprintf("%#v", this.Notification)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetNotificationResponse_Notification) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&clairpb.GetNotificationResponse_Notification{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Created: "+fmt.Sprintf("%#v", this.Created)+",\n")
	s = append(s, "Notified: "+fmt.Sprintf("%#v", this.Notified)+",\n")
	s = append(s, "Deleted: "+fmt.Sprintf("%#v", this.Deleted)+",\n")
	if this.Old != nil {
		s = append(s, "Old: "+fmt.Sprintf("%#v", this.Old)+",\n")
	}
	if this.New != nil {
		s = append(s, "New: "+fmt.Sprintf("%#v", this.New)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PagedVulnerableAncestries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&clairpb.PagedVulnerableAncestries{")
	s = append(s, "CurrentPage: "+fmt.Sprintf("%#v", this.CurrentPage)+",\n")
	s = append(s, "NextPage: "+fmt.Sprintf("%#v", this.NextPage)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.Vulnerability != nil {
		s = append(s, "Vulnerability: "+fmt.Sprintf("%#v", this.Vulnerability)+",\n")
	}
	if this.Ancestries != nil {
		s = append(s, "Ancestries: "+fmt.Sprintf("%#v", this.Ancestries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PagedVulnerableAncestries_IndexedAncestryName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&clairpb.PagedVulnerableAncestries_IndexedAncestryName{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MarkNotificationAsReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&clairpb.MarkNotificationAsReadRequest{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MarkNotificationAsReadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&clairpb.MarkNotificationAsReadResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClair(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AncestryServiceClient is the client API for AncestryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AncestryServiceClient interface {
	// The RPC used to read the results of scanning for a particular ancestry.
	GetAncestry(ctx context.Context, in *GetAncestryRequest, opts ...grpc.CallOption) (*GetAncestryResponse, error)
	// The RPC used to create a new scan of an ancestry.
	PostAncestry(ctx context.Context, in *PostAncestryRequest, opts ...grpc.CallOption) (*PostAncestryResponse, error)
}

type ancestryServiceClient struct {
	cc *grpc.ClientConn
}

func NewAncestryServiceClient(cc *grpc.ClientConn) AncestryServiceClient {
	return &ancestryServiceClient{cc}
}

func (c *ancestryServiceClient) GetAncestry(ctx context.Context, in *GetAncestryRequest, opts ...grpc.CallOption) (*GetAncestryResponse, error) {
	out := new(GetAncestryResponse)
	err := c.cc.Invoke(ctx, "/coreos.clair.AncestryService/GetAncestry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ancestryServiceClient) PostAncestry(ctx context.Context, in *PostAncestryRequest, opts ...grpc.CallOption) (*PostAncestryResponse, error) {
	out := new(PostAncestryResponse)
	err := c.cc.Invoke(ctx, "/coreos.clair.AncestryService/PostAncestry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AncestryServiceServer is the server API for AncestryService service.
type AncestryServiceServer interface {
	// The RPC used to read the results of scanning for a particular ancestry.
	GetAncestry(context.Context, *GetAncestryRequest) (*GetAncestryResponse, error)
	// The RPC used to create a new scan of an ancestry.
	PostAncestry(context.Context, *PostAncestryRequest) (*PostAncestryResponse, error)
}

func RegisterAncestryServiceServer(s *grpc.Server, srv AncestryServiceServer) {
	s.RegisterService(&_AncestryService_serviceDesc, srv)
}

func _AncestryService_GetAncestry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAncestryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AncestryServiceServer).GetAncestry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coreos.clair.AncestryService/GetAncestry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AncestryServiceServer).GetAncestry(ctx, req.(*GetAncestryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AncestryService_PostAncestry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostAncestryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AncestryServiceServer).PostAncestry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coreos.clair.AncestryService/PostAncestry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AncestryServiceServer).PostAncestry(ctx, req.(*PostAncestryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AncestryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "coreos.clair.AncestryService",
	HandlerType: (*AncestryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAncestry",
			Handler:    _AncestryService_GetAncestry_Handler,
		},
		{
			MethodName: "PostAncestry",
			Handler:    _AncestryService_PostAncestry_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v3/clairpb/clair.proto",
}

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotificationServiceClient interface {
	// The RPC used to get a particularly Notification.
	GetNotification(ctx context.Context, in *GetNotificationRequest, opts ...grpc.CallOption) (*GetNotificationResponse, error)
	// The RPC used to mark a Notification as read after it has been processed.
	MarkNotificationAsRead(ctx context.Context, in *MarkNotificationAsReadRequest, opts ...grpc.CallOption) (*MarkNotificationAsReadResponse, error)
}

type notificationServiceClient struct {
	cc *grpc.ClientConn
}

func NewNotificationServiceClient(cc *grpc.ClientConn) NotificationServiceClient {
	return &notificationServiceClient{cc}
}

func (c *notificationServiceClient) GetNotification(ctx context.Context, in *GetNotificationRequest, opts ...grpc.CallOption) (*GetNotificationResponse, error) {
	out := new(GetNotificationResponse)
	err := c.cc.Invoke(ctx, "/coreos.clair.NotificationService/GetNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) MarkNotificationAsRead(ctx context.Context, in *MarkNotificationAsReadRequest, opts ...grpc.CallOption) (*MarkNotificationAsReadResponse, error) {
	out := new(MarkNotificationAsReadResponse)
	err := c.cc.Invoke(ctx, "/coreos.clair.NotificationService/MarkNotificationAsRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServiceServer is the server API for NotificationService service.
type NotificationServiceServer interface {
	// The RPC used to get a particularly Notification.
	GetNotification(context.Context, *GetNotificationRequest) (*GetNotificationResponse, error)
	// The RPC used to mark a Notification as read after it has been processed.
	MarkNotificationAsRead(context.Context, *MarkNotificationAsReadRequest) (*MarkNotificationAsReadResponse, error)
}

func RegisterNotificationServiceServer(s *grpc.Server, srv NotificationServiceServer) {
	s.RegisterService(&_NotificationService_serviceDesc, srv)
}

func _NotificationService_GetNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coreos.clair.NotificationService/GetNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetNotification(ctx, req.(*GetNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_MarkNotificationAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkNotificationAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).MarkNotificationAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coreos.clair.NotificationService/MarkNotificationAsRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).MarkNotificationAsRead(ctx, req.(*MarkNotificationAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotificationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "coreos.clair.NotificationService",
	HandlerType: (*NotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNotification",
			Handler:    _NotificationService_GetNotification_Handler,
		},
		{
			MethodName: "MarkNotificationAsRead",
			Handler:    _NotificationService_MarkNotificationAsRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v3/clairpb/clair.proto",
}

func (m *Vulnerability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vulnerability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.NamespaceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.NamespaceName)))
		i += copy(dAtA[i:], m.NamespaceName)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.FixedBy) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.FixedBy)))
		i += copy(dAtA[i:], m.FixedBy)
	}
	if len(m.AffectedVersions) > 0 {
		for _, msg := range m.AffectedVersions {
			dAtA[i] = 0x42
			i++
			i = encodeVarintClair(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Feature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.NamespaceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.NamespaceName)))
		i += copy(dAtA[i:], m.NamespaceName)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.VersionFormat) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.VersionFormat)))
		i += copy(dAtA[i:], m.VersionFormat)
	}
	if len(m.Vulnerabilities) > 0 {
		for _, msg := range m.Vulnerabilities {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintClair(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Layer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Layer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *ClairStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClairStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Listers) > 0 {
		for _, s := range m.Listers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Detectors) > 0 {
		for _, s := range m.Detectors {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LastUpdateTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.LastUpdateTime.Size()))
		n1, err := m.LastUpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GetAncestryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAncestryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AncestryName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.AncestryName)))
		i += copy(dAtA[i:], m.AncestryName)
	}
	if m.WithVulnerabilities {
		dAtA[i] = 0x10
		i++
		if m.WithVulnerabilities {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WithFeatures {
		dAtA[i] = 0x18
		i++
		if m.WithFeatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetAncestryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAncestryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ancestry != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Ancestry.Size()))
		n2, err := m.Ancestry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Status.Size()))
		n3, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *GetAncestryResponse_Ancestry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAncestryResponse_Ancestry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Features) > 0 {
		for _, msg := range m.Features {
			dAtA[i] = 0x12
			i++
			i = encodeVarintClair(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Layers) > 0 {
		for _, msg := range m.Layers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintClair(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ScannedListers) > 0 {
		for _, s := range m.ScannedListers {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ScannedDetectors) > 0 {
		for _, s := range m.ScannedDetectors {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PostAncestryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostAncestryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AncestryName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.AncestryName)))
		i += copy(dAtA[i:], m.AncestryName)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Layers) > 0 {
		for _, msg := range m.Layers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintClair(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PostAncestryRequest_PostLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostAncestryRequest_PostLayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Headers) > 0 {
		for k, _ := range m.Headers {
			dAtA[i] = 0x1a
			i++
			v := m.Headers[k]
			mapSize := 1 + len(k) + sovClair(uint64(len(k))) + 1 + len(v) + sovClair(uint64(len(v)))
			i = encodeVarintClair(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintClair(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintClair(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *PostAncestryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostAncestryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Status.Size()))
		n4, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *GetNotificationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNotificationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OldVulnerabilityPage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.OldVulnerabilityPage)))
		i += copy(dAtA[i:], m.OldVulnerabilityPage)
	}
	if len(m.NewVulnerabilityPage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.NewVulnerabilityPage)))
		i += copy(dAtA[i:], m.NewVulnerabilityPage)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Limit))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetNotificationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNotificationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Notification != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Notification.Size()))
		n5, err := m.Notification.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *GetNotificationResponse_Notification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNotificationResponse_Notification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Notified) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Notified)))
		i += copy(dAtA[i:], m.Notified)
	}
	if len(m.Deleted) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Deleted)))
		i += copy(dAtA[i:], m.Deleted)
	}
	if m.Old != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Old.Size()))
		n6, err := m.Old.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.New != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.New.Size()))
		n7, err := m.New.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *PagedVulnerableAncestries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedVulnerableAncestries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CurrentPage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.CurrentPage)))
		i += copy(dAtA[i:], m.CurrentPage)
	}
	if len(m.NextPage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.NextPage)))
		i += copy(dAtA[i:], m.NextPage)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Limit))
	}
	if m.Vulnerability != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Vulnerability.Size()))
		n8, err := m.Vulnerability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Ancestries) > 0 {
		for _, msg := range m.Ancestries {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintClair(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PagedVulnerableAncestries_IndexedAncestryName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedVulnerableAncestries_IndexedAncestryName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintClair(dAtA, i, uint64(m.Index))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *MarkNotificationAsReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkNotificationAsReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClair(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *MarkNotificationAsReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkNotificationAsReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintClair(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Vulnerability) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.NamespaceName)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.FixedBy)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if len(m.AffectedVersions) > 0 {
		for _, e := range m.AffectedVersions {
			l = e.Size()
			n += 1 + l + sovClair(uint64(l))
		}
	}
	return n
}

func (m *Feature) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.NamespaceName)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.VersionFormat)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if len(m.Vulnerabilities) > 0 {
		for _, e := range m.Vulnerabilities {
			l = e.Size()
			n += 1 + l + sovClair(uint64(l))
		}
	}
	return n
}

func (m *Layer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *ClairStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Listers) > 0 {
		for _, s := range m.Listers {
			l = len(s)
			n += 1 + l + sovClair(uint64(l))
		}
	}
	if len(m.Detectors) > 0 {
		for _, s := range m.Detectors {
			l = len(s)
			n += 1 + l + sovClair(uint64(l))
		}
	}
	if m.LastUpdateTime != nil {
		l = m.LastUpdateTime.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *GetAncestryRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AncestryName)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if m.WithVulnerabilities {
		n += 2
	}
	if m.WithFeatures {
		n += 2
	}
	return n
}

func (m *GetAncestryResponse) Size() (n int) {
	var l int
	_ = l
	if m.Ancestry != nil {
		l = m.Ancestry.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *GetAncestryResponse_Ancestry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if len(m.Features) > 0 {
		for _, e := range m.Features {
			l = e.Size()
			n += 1 + l + sovClair(uint64(l))
		}
	}
	if len(m.Layers) > 0 {
		for _, e := range m.Layers {
			l = e.Size()
			n += 1 + l + sovClair(uint64(l))
		}
	}
	if len(m.ScannedListers) > 0 {
		for _, s := range m.ScannedListers {
			l = len(s)
			n += 1 + l + sovClair(uint64(l))
		}
	}
	if len(m.ScannedDetectors) > 0 {
		for _, s := range m.ScannedDetectors {
			l = len(s)
			n += 1 + l + sovClair(uint64(l))
		}
	}
	return n
}

func (m *PostAncestryRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AncestryName)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if len(m.Layers) > 0 {
		for _, e := range m.Layers {
			l = e.Size()
			n += 1 + l + sovClair(uint64(l))
		}
	}
	return n
}

func (m *PostAncestryRequest_PostLayer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClair(uint64(len(k))) + 1 + len(v) + sovClair(uint64(len(v)))
			n += mapEntrySize + 1 + sovClair(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PostAncestryResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *GetNotificationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.OldVulnerabilityPage)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.NewVulnerabilityPage)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovClair(uint64(m.Limit))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *GetNotificationResponse) Size() (n int) {
	var l int
	_ = l
	if m.Notification != nil {
		l = m.Notification.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *GetNotificationResponse_Notification) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Notified)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.Deleted)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if m.Old != nil {
		l = m.Old.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	if m.New != nil {
		l = m.New.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *PagedVulnerableAncestries) Size() (n int) {
	var l int
	_ = l
	l = len(m.CurrentPage)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	l = len(m.NextPage)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovClair(uint64(m.Limit))
	}
	if m.Vulnerability != nil {
		l = m.Vulnerability.Size()
		n += 1 + l + sovClair(uint64(l))
	}
	if len(m.Ancestries) > 0 {
		for _, e := range m.Ancestries {
			l = e.Size()
			n += 1 + l + sovClair(uint64(l))
		}
	}
	return n
}

func (m *PagedVulnerableAncestries_IndexedAncestryName) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovClair(uint64(m.Index))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *MarkNotificationAsReadRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClair(uint64(l))
	}
	return n
}

func (m *MarkNotificationAsReadResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovClair(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClair(x uint64) (n int) {
	return sovClair(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Vulnerability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vulnerability{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`NamespaceName:` + fmt.Sprintf("%v", this.NamespaceName) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Link:` + fmt.Sprintf("%v", this.Link) + `,`,
		`Severity:` + fmt.Sprintf("%v", this.Severity) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`FixedBy:` + fmt.Sprintf("%v", this.FixedBy) + `,`,
		`AffectedVersions:` + strings.Replace(fmt.Sprintf("%v", this.AffectedVersions), "Feature", "Feature", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Feature) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Feature{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`NamespaceName:` + fmt.Sprintf("%v", this.NamespaceName) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`VersionFormat:` + fmt.Sprintf("%v", this.VersionFormat) + `,`,
		`Vulnerabilities:` + strings.Replace(fmt.Sprintf("%v", this.Vulnerabilities), "Vulnerability", "Vulnerability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClairStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClairStatus{`,
		`Listers:` + fmt.Sprintf("%v", this.Listers) + `,`,
		`Detectors:` + fmt.Sprintf("%v", this.Detectors) + `,`,
		`LastUpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAncestryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAncestryRequest{`,
		`AncestryName:` + fmt.Sprintf("%v", this.AncestryName) + `,`,
		`WithVulnerabilities:` + fmt.Sprintf("%v", this.WithVulnerabilities) + `,`,
		`WithFeatures:` + fmt.Sprintf("%v", this.WithFeatures) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAncestryResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAncestryResponse{`,
		`Ancestry:` + strings.Replace(fmt.Sprintf("%v", this.Ancestry), "GetAncestryResponse_Ancestry", "GetAncestryResponse_Ancestry", 1) + `,`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "ClairStatus", "ClairStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAncestryResponse_Ancestry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAncestryResponse_Ancestry{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Features:` + strings.Replace(fmt.Sprintf("%v", this.Features), "Feature", "Feature", 1) + `,`,
		`Layers:` + strings.Replace(fmt.Sprintf("%v", this.Layers), "Layer", "Layer", 1) + `,`,
		`ScannedListers:` + fmt.Sprintf("%v", this.ScannedListers) + `,`,
		`ScannedDetectors:` + fmt.Sprintf("%v", this.ScannedDetectors) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PostAncestryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PostAncestryRequest{`,
		`AncestryName:` + fmt.Sprintf("%v", this.AncestryName) + `,`,
		`Format:` + fmt.Sprintf("%v", this.Format) + `,`,
		`Layers:` + strings.Replace(fmt.Sprintf("%v", this.Layers), "PostAncestryRequest_PostLayer", "PostAncestryRequest_PostLayer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PostAncestryRequest_PostLayer) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]string{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%v: %v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	s := strings.Join([]string{`&PostAncestryRequest_PostLayer{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Headers:` + mapStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *PostAncestryResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PostAncestryResponse{`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "ClairStatus", "ClairStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNotificationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNotificationRequest{`,
		`OldVulnerabilityPage:` + fmt.Sprintf("%v", this.OldVulnerabilityPage) + `,`,
		`NewVulnerabilityPage:` + fmt.Sprintf("%v", this.NewVulnerabilityPage) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNotificationResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNotificationResponse{`,
		`Notification:` + strings.Replace(fmt.Sprintf("%v", this.Notification), "GetNotificationResponse_Notification", "GetNotificationResponse_Notification", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNotificationResponse_Notification) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNotificationResponse_Notification{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Created:` + fmt.Sprintf("%v", this.Created) + `,`,
		`Notified:` + fmt.Sprintf("%v", this.Notified) + `,`,
		`Deleted:` + fmt.Sprintf("%v", this.Deleted) + `,`,
		`Old:` + strings.Replace(fmt.Sprintf("%v", this.Old), "PagedVulnerableAncestries", "PagedVulnerableAncestries", 1) + `,`,
		`New:` + strings.Replace(fmt.Sprintf("%v", this.New), "PagedVulnerableAncestries", "PagedVulnerableAncestries", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PagedVulnerableAncestries) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PagedVulnerableAncestries{`,
		`CurrentPage:` + fmt.Sprintf("%v", this.CurrentPage) + `,`,
		`NextPage:` + fmt.Sprintf("%v", this.NextPage) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Vulnerability:` + strings.Replace(fmt.Sprintf("%v", this.Vulnerability), "Vulnerability", "Vulnerability", 1) + `,`,
		`Ancestries:` + strings.Replace(fmt.Sprintf("%v", this.Ancestries), "PagedVulnerableAncestries_IndexedAncestryName", "PagedVulnerableAncestries_IndexedAncestryName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PagedVulnerableAncestries_IndexedAncestryName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PagedVulnerableAncestries_IndexedAncestryName{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MarkNotificationAsReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MarkNotificationAsReadRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MarkNotificationAsReadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MarkNotificationAsReadResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringClair(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Vulnerability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vulnerability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vulnerability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AffectedVersions = append(m.AffectedVersions, &Feature{})
			if err := m.AffectedVersions[len(m.AffectedVersions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vulnerabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vulnerabilities = append(m.Vulnerabilities, &Vulnerability{})
			if err := m.Vulnerabilities[len(m.Vulnerabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Layer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClairStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClairStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClairStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listers = append(m.Listers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detectors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detectors = append(m.Detectors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateTime == nil {
				m.LastUpdateTime = &types.Timestamp{}
			}
			if err := m.LastUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAncestryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAncestryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAncestryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncestryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AncestryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVulnerabilities", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithVulnerabilities = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithFeatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithFeatures = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAncestryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAncestryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAncestryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ancestry == nil {
				m.Ancestry = &GetAncestryResponse_Ancestry{}
			}
			if err := m.Ancestry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ClairStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAncestryResponse_Ancestry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ancestry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ancestry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, &Feature{})
			if err := m.Features[len(m.Features)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, &Layer{})
			if err := m.Layers[len(m.Layers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScannedListers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScannedListers = append(m.ScannedListers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScannedDetectors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScannedDetectors = append(m.ScannedDetectors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostAncestryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostAncestryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostAncestryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncestryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AncestryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, &PostAncestryRequest_PostLayer{})
			if err := m.Layers[len(m.Layers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostAncestryRequest_PostLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClair
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClair
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClair
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClair
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClair
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClair(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClair
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostAncestryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostAncestryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostAncestryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ClairStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNotificationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNotificationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNotificationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVulnerabilityPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVulnerabilityPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVulnerabilityPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVulnerabilityPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNotificationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNotificationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNotificationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Notification == nil {
				m.Notification = &GetNotificationResponse_Notification{}
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNotificationResponse_Notification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deleted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Old", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Old == nil {
				m.Old = &PagedVulnerableAncestries{}
			}
			if err := m.Old.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.New == nil {
				m.New = &PagedVulnerableAncestries{}
			}
			if err := m.New.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedVulnerableAncestries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PagedVulnerableAncestries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PagedVulnerableAncestries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vulnerability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vulnerability == nil {
				m.Vulnerability = &Vulnerability{}
			}
			if err := m.Vulnerability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ancestries = append(m.Ancestries, &PagedVulnerableAncestries_IndexedAncestryName{})
			if err := m.Ancestries[len(m.Ancestries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedVulnerableAncestries_IndexedAncestryName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedAncestryName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedAncestryName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkNotificationAsReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkNotificationAsReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkNotificationAsReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClair
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClair
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkNotificationAsReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClair
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkNotificationAsReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkNotificationAsReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipClair(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClair
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClair(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClair
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClair
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClair
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClair
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClair
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClair(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClair = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClair   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/v3/clairpb/clair.proto", fileDescriptor_clair_9de75ee587b4d16c) }

var fileDescriptor_clair_9de75ee587b4d16c = []byte{
	// 1242 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcb, 0x6f, 0xdc, 0x44,
	0x18, 0x8f, 0x9d, 0x6c, 0x76, 0xf3, 0xed, 0xe6, 0xd1, 0xd9, 0x6d, 0xea, 0x38, 0xad, 0x49, 0x0c,
	0x55, 0xab, 0x16, 0xed, 0xaa, 0x5b, 0x0e, 0xa5, 0x1c, 0x50, 0xfa, 0xa4, 0xa8, 0x54, 0x95, 0x0b,
	0x39, 0xc0, 0x61, 0x35, 0xb1, 0xbf, 0x4d, 0xac, 0x78, 0xed, 0xc5, 0x33, 0x9b, 0x74, 0x55, 0x55,
	0x42, 0x5c, 0xb9, 0xf0, 0x38, 0xf0, 0x2f, 0xc0, 0x85, 0x7f, 0x82, 0x0b, 0x07, 0x0e, 0x15, 0x70,
	0xe0, 0x00, 0x12, 0x5d, 0x90, 0xe8, 0xb1, 0x17, 0xee, 0x68, 0xc6, 0x63, 0xc7, 0x4e, 0xb6, 0x49,
	0x0a, 0xa7, 0xf5, 0xf7, 0x7e, 0xfd, 0xbe, 0xf9, 0x12, 0x30, 0x69, 0xdf, 0x6f, 0xed, 0x5c, 0x6e,
	0xb9, 0x01, 0xf5, 0xe3, 0xfe, 0x46, 0xf2, 0xdb, 0xec, 0xc7, 0x11, 0x8f, 0x48, 0xcd, 0x8d, 0x62,
	0x8c, 0x58, 0x53, 0xf2, 0xcc, 0x57, 0x36, 0xa3, 0x68, 0x33, 0xc0, 0x96, 0x94, 0x6d, 0x0c, 0xba,
	0x2d, 0xee, 0xf7, 0x90, 0x71, 0xda, 0xeb, 0x27, 0xea, 0xe6, 0x69, 0xa5, 0x20, 0x3c, 0xd2, 0x30,
	0x8c, 0x38, 0xe5, 0x7e, 0x14, 0xb2, 0x44, 0x6a, 0x7f, 0xad, 0xc3, 0xec, 0xfa, 0x20, 0x08, 0x31,
	0xa6, 0x1b, 0x7e, 0xe0, 0xf3, 0x21, 0x21, 0x30, 0x15, 0xd2, 0x1e, 0x1a, 0xda, 0x8a, 0x76, 0x7e,
	0xc6, 0x91, 0xdf, 0xe4, 0x2c, 0xcc, 0x89, 0x5f, 0xd6, 0xa7, 0x2e, 0x76, 0xa4, 0x54, 0x97, 0xd2,
	0xd9, 0x8c, 0x7b, 0x4f, 0xa8, 0xad, 0x40, 0xd5, 0x43, 0xe6, 0xc6, 0x7e, 0x5f, 0x84, 0x30, 0x26,
	0xa5, 0x4e, 0x9e, 0x25, 0x9c, 0x07, 0x7e, 0xb8, 0x6d, 0x4c, 0x25, 0xce, 0xc5, 0x37, 0x31, 0xa1,
	0xc2, 0x70, 0x07, 0x63, 0x9f, 0x0f, 0x8d, 0x92, 0xe4, 0x67, 0xb4, 0x90, 0xf5, 0x90, 0x53, 0x8f,
	0x72, 0x6a, 0x4c, 0x27, 0xb2, 0x94, 0x26, 0x4b, 0x50, 0xe9, 0xfa, 0x0f, 0xd1, 0xeb, 0x6c, 0x0c,
	0x8d, 0xb2, 0x94, 0x95, 0x25, 0x7d, 0x6d, 0x48, 0xae, 0xc1, 0x09, 0xda, 0xed, 0xa2, 0xcb, 0xd1,
	0xeb, 0xec, 0x60, 0xcc, 0x44, 0xc1, 0x46, 0x65, 0x65, 0xf2, 0x7c, 0xb5, 0x7d, 0xb2, 0x99, 0x6f,
	0x5f, 0xf3, 0x16, 0x52, 0x3e, 0x88, 0xd1, 0x59, 0x48, 0xf5, 0xd7, 0x95, 0xba, 0xfd, 0xa3, 0x06,
	0x65, 0x25, 0xfd, 0x3f, 0x3d, 0x31, 0xa0, 0xac, 0x32, 0x50, 0xfd, 0x48, 0x49, 0xe1, 0x40, 0x7d,
	0x76, 0xba, 0x51, 0xdc, 0xa3, 0x5c, 0x75, 0x65, 0x56, 0x71, 0x6f, 0x49, 0x26, 0xb9, 0x09, 0xf3,
	0x3b, 0xb9, 0x01, 0xf9, 0xc8, 0x8c, 0x92, 0xac, 0x64, 0xb9, 0x58, 0x49, 0x61, 0x8a, 0xce, 0x7e,
	0x1b, 0x7b, 0x19, 0x4a, 0x77, 0xe9, 0x10, 0x63, 0x51, 0xcb, 0x16, 0x65, 0x5b, 0x69, 0x2d, 0xe2,
	0xdb, 0xfe, 0x4c, 0x83, 0xea, 0x75, 0xe1, 0xe5, 0x01, 0xa7, 0x7c, 0xc0, 0x44, 0xd2, 0x81, 0xcf,
	0x38, 0xc6, 0xcc, 0xd0, 0x56, 0x26, 0x45, 0xd2, 0x8a, 0x24, 0xa7, 0x61, 0xc6, 0x43, 0x8e, 0x2e,
	0x8f, 0x62, 0x66, 0xe8, 0x52, 0xb6, 0xc7, 0x20, 0x37, 0x60, 0x21, 0xa0, 0x8c, 0x77, 0x06, 0x7d,
	0x8f, 0x72, 0xec, 0x08, 0x28, 0xca, 0xaa, 0xab, 0x6d, 0xb3, 0x99, 0xc0, 0xb0, 0x99, 0xe2, 0xb4,
	0xf9, 0x7e, 0x8a, 0x53, 0x67, 0x4e, 0xd8, 0x7c, 0x20, 0x4d, 0x04, 0xd3, 0xfe, 0x42, 0x03, 0x72,
	0x1b, 0xf9, 0x5a, 0xe8, 0x22, 0xe3, 0xf1, 0xd0, 0xc1, 0x8f, 0x07, 0xc8, 0x38, 0x79, 0x15, 0x66,
	0xa9, 0x62, 0x75, 0x72, 0xd3, 0xa8, 0xa5, 0x4c, 0xd9, 0xee, 0x4b, 0xd0, 0xd8, 0xf5, 0xf9, 0x56,
	0x67, 0x7f, 0xcb, 0xc4, 0x6c, 0x2a, 0x4e, 0x5d, 0xc8, 0xd6, 0x8b, 0x22, 0xe1, 0x57, 0x9a, 0x74,
	0x93, 0x61, 0x33, 0x99, 0x71, 0xc5, 0xa9, 0x09, 0xa6, 0x02, 0x00, 0xb3, 0xff, 0xd6, 0xa1, 0x5e,
	0xc8, 0x89, 0xf5, 0xa3, 0x90, 0x21, 0xb9, 0x05, 0x95, 0x34, 0xbe, 0xcc, 0xa7, 0xda, 0xbe, 0x50,
	0x1c, 0xcb, 0x18, 0xa3, 0x66, 0xc6, 0xc8, 0x6c, 0xc9, 0x25, 0x98, 0x66, 0xb2, 0xf7, 0x32, 0xd3,
	0x6a, 0x7b, 0xa9, 0xe8, 0x25, 0x37, 0x1c, 0x47, 0x29, 0x9a, 0xbf, 0x68, 0x50, 0x49, 0x3d, 0x8d,
	0x45, 0xe8, 0x25, 0xa8, 0x64, 0x35, 0xe9, 0x87, 0x81, 0x3f, 0x53, 0x23, 0x17, 0x61, 0x3a, 0x10,
	0x28, 0x11, 0x4d, 0x10, 0x06, 0xf5, 0xa2, 0x81, 0x44, 0x90, 0xa3, 0x54, 0xc8, 0x39, 0x98, 0x67,
	0x2e, 0x0d, 0x43, 0xf4, 0x3a, 0x29, 0x5a, 0xa6, 0x24, 0x22, 0xe6, 0x14, 0xfb, 0xae, 0x02, 0xcd,
	0x45, 0x38, 0x91, 0x2a, 0xee, 0x81, 0xa7, 0x24, 0x55, 0x17, 0x94, 0xe0, 0x46, 0xca, 0xb7, 0x7f,
	0xd7, 0xa1, 0x7e, 0x3f, 0x62, 0xff, 0x6d, 0xfc, 0x8b, 0x30, 0xad, 0x76, 0x29, 0x59, 0x46, 0x45,
	0x91, 0xeb, 0xfb, 0xea, 0xba, 0x58, 0xac, 0x6b, 0x4c, 0x3c, 0xc9, 0x2b, 0xd4, 0x6b, 0x7e, 0xaf,
	0xc1, 0x4c, 0xc6, 0x1d, 0xb7, 0x47, 0x82, 0xd7, 0xa7, 0x7c, 0x4b, 0x05, 0x97, 0xdf, 0xc4, 0x81,
	0xf2, 0x16, 0x52, 0x6f, 0x2f, 0xf6, 0x95, 0x97, 0x88, 0xdd, 0x7c, 0x27, 0x31, 0xbd, 0x19, 0x0a,
	0x69, 0xea, 0xc8, 0xbc, 0x0a, 0xb5, 0xbc, 0x80, 0x2c, 0xc0, 0xe4, 0x36, 0x0e, 0x55, 0x2a, 0xe2,
	0x93, 0x34, 0xa0, 0xb4, 0x43, 0x83, 0x41, 0xfa, 0x28, 0x25, 0xc4, 0x55, 0xfd, 0x8a, 0x66, 0xdf,
	0x81, 0x46, 0x31, 0xa4, 0x42, 0xf2, 0x1e, 0x02, 0xb5, 0x63, 0x22, 0xd0, 0xfe, 0x4e, 0x83, 0xc5,
	0xdb, 0xc8, 0xef, 0x45, 0xdc, 0xef, 0xfa, 0xae, 0xbc, 0x2b, 0xe9, 0xb4, 0xde, 0x80, 0xc5, 0x28,
	0xf0, 0x0a, 0x6b, 0x38, 0xec, 0xf4, 0xe9, 0x66, 0x3a, 0xb6, 0x46, 0x14, 0x78, 0x85, 0x17, 0xeb,
	0x3e, 0xdd, 0x44, 0x61, 0x15, 0xe2, 0xee, 0x38, 0xab, 0xa4, 0x8c, 0x46, 0x88, 0xbb, 0x07, 0xad,
	0x1a, 0x50, 0x0a, 0xfc, 0x9e, 0xcf, 0xe5, 0xe2, 0x96, 0x9c, 0x84, 0xc8, 0x36, 0x62, 0x6a, 0x6f,
	0x23, 0xec, 0xdf, 0x74, 0x38, 0x75, 0x20, 0x61, 0x55, 0xff, 0x3a, 0xd4, 0xc2, 0x1c, 0x5f, 0x75,
	0xa1, 0x7d, 0x60, 0x9b, 0xc7, 0x19, 0x37, 0x0b, 0xcc, 0x82, 0x1f, 0xf3, 0x99, 0x06, 0xb5, 0xbc,
	0x78, 0xec, 0xaa, 0x1a, 0x50, 0x76, 0x63, 0xa4, 0x1c, 0x3d, 0x55, 0x69, 0x4a, 0x8a, 0x0b, 0x98,
	0xb8, 0x43, 0x4f, 0x1d, 0x90, 0x8c, 0x16, 0x56, 0x1e, 0x06, 0x28, 0xac, 0x92, 0x2a, 0x53, 0x92,
	0xbc, 0x09, 0x93, 0x51, 0xe0, 0xc9, 0x73, 0x5a, 0x6d, 0x9f, 0xdb, 0x07, 0x38, 0xba, 0x89, 0x59,
	0xef, 0x03, 0x54, 0x40, 0xf0, 0x91, 0x39, 0xc2, 0x46, 0x98, 0x86, 0xb8, 0x2b, 0xaf, 0xed, 0xcb,
	0x98, 0x86, 0xb8, 0x6b, 0xff, 0xa4, 0xc3, 0xd2, 0x0b, 0x55, 0xc8, 0x2a, 0xd4, 0xdc, 0x41, 0x1c,
	0x63, 0xc8, 0xf3, 0x40, 0xa8, 0x2a, 0x9e, 0x9c, 0xe4, 0x32, 0xcc, 0x84, 0xf8, 0x90, 0xe7, 0x47,
	0x5e, 0x11, 0x8c, 0x43, 0xc6, 0xbc, 0x06, 0xb3, 0x05, 0xb8, 0xc8, 0x4e, 0x1c, 0x71, 0x1c, 0x8b,
	0x16, 0xe4, 0x23, 0x00, 0x9a, 0xa5, 0xa9, 0x8e, 0xeb, 0x5b, 0xc7, 0x2c, 0xbc, 0x79, 0x27, 0xf4,
	0xf0, 0x21, 0x7a, 0x6b, 0xb9, 0x57, 0xc8, 0xc9, 0xb9, 0x33, 0xdf, 0x86, 0xfa, 0x18, 0x15, 0x51,
	0x8c, 0x2f, 0xd8, 0xb2, 0x0b, 0x25, 0x27, 0x21, 0x32, 0x68, 0xe8, 0x39, 0xcc, 0x5e, 0x86, 0x33,
	0xef, 0xd1, 0x78, 0x3b, 0x0f, 0xa1, 0x35, 0xe6, 0x20, 0xf5, 0xd2, 0x55, 0x1b, 0x83, 0x27, 0x7b,
	0x05, 0xac, 0x17, 0x19, 0x25, 0x88, 0x6d, 0xff, 0xa3, 0xc1, 0x7c, 0x9a, 0xd1, 0x03, 0x8c, 0x77,
	0x7c, 0x17, 0xc9, 0x00, 0xaa, 0xb9, 0x73, 0x45, 0x56, 0x0e, 0xb9, 0x64, 0x32, 0xb4, 0xb9, 0x7a,
	0xe4, 0xad, 0xb3, 0x57, 0x3f, 0xfd, 0xf9, 0xaf, 0xaf, 0xf4, 0x65, 0xb2, 0xd4, 0x4a, 0x1f, 0xea,
	0xd6, 0xa3, 0xc2, 0x3b, 0xfe, 0x98, 0x6c, 0x43, 0x2d, 0xff, 0x22, 0x91, 0xd5, 0x23, 0x1f, 0x48,
	0xd3, 0x3e, 0x4c, 0x45, 0x45, 0x6e, 0xc8, 0xc8, 0x73, 0xf6, 0x4c, 0x16, 0xf9, 0xaa, 0x76, 0xa1,
	0xfd, 0xad, 0x0e, 0xf5, 0x7c, 0x5b, 0xd2, 0xda, 0x1f, 0xc3, 0xfc, 0xbe, 0xe5, 0x26, 0xaf, 0x1d,
	0xb1, 0xfb, 0x49, 0x2a, 0x67, 0x8f, 0xf5, 0x42, 0xd8, 0x67, 0x64, 0x36, 0xa7, 0xc8, 0xc9, 0x56,
	0xfe, 0x75, 0x60, 0xad, 0x47, 0x49, 0x0f, 0xbe, 0xd4, 0x60, 0x71, 0xfc, 0xc4, 0xc8, 0xbe, 0x5b,
	0x75, 0x28, 0x18, 0xcc, 0xd7, 0x8f, 0xa7, 0x5c, 0x4c, 0xea, 0xc2, 0xf8, 0xa4, 0xae, 0xbd, 0xfb,
	0xe4, 0xa9, 0x35, 0xf1, 0xeb, 0x53, 0x6b, 0xe2, 0xf9, 0x53, 0x4b, 0xfb, 0x64, 0x64, 0x69, 0xdf,
	0x8c, 0x2c, 0xed, 0x87, 0x91, 0xa5, 0x3d, 0x19, 0x59, 0xda, 0x1f, 0x23, 0x4b, 0x7b, 0x36, 0xb2,
	0x26, 0x9e, 0x8f, 0x2c, 0xed, 0xf3, 0x3f, 0xad, 0x09, 0xa8, 0xbb, 0x51, 0xaf, 0x18, 0xbd, 0xbf,
	0xf1, 0x61, 0x59, 0xfd, 0x07, 0xb3, 0x31, 0x2d, 0xff, 0xf0, 0xbb, 0xfc, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xa5, 0xdc, 0x78, 0xef, 0xda, 0x0c, 0x00, 0x00,
}
