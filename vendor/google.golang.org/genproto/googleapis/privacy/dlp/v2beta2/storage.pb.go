// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/privacy/dlp/v2beta2/storage.proto

package dlp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Categorization of results based on how likely they are to represent a match,
// based on the number of elements they contain which imply a match.
type Likelihood int32

const (
	// Default value; information with all likelihoods is included.
	Likelihood_LIKELIHOOD_UNSPECIFIED Likelihood = 0
	// Few matching elements.
	Likelihood_VERY_UNLIKELY Likelihood = 1
	Likelihood_UNLIKELY      Likelihood = 2
	// Some matching elements.
	Likelihood_POSSIBLE Likelihood = 3
	Likelihood_LIKELY   Likelihood = 4
	// Many matching elements.
	Likelihood_VERY_LIKELY Likelihood = 5
)

var Likelihood_name = map[int32]string{
	0: "LIKELIHOOD_UNSPECIFIED",
	1: "VERY_UNLIKELY",
	2: "UNLIKELY",
	3: "POSSIBLE",
	4: "LIKELY",
	5: "VERY_LIKELY",
}
var Likelihood_value = map[string]int32{
	"LIKELIHOOD_UNSPECIFIED": 0,
	"VERY_UNLIKELY":          1,
	"UNLIKELY":               2,
	"POSSIBLE":               3,
	"LIKELY":                 4,
	"VERY_LIKELY":            5,
}

func (x Likelihood) String() string {
	return proto.EnumName(Likelihood_name, int32(x))
}
func (Likelihood) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// Type of information detected by the API.
type InfoType struct {
	// Name of the information type.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *InfoType) Reset()                    { *m = InfoType{} }
func (m *InfoType) String() string            { return proto.CompactTextString(m) }
func (*InfoType) ProtoMessage()               {}
func (*InfoType) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *InfoType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Custom information type provided by the user. Used to find domain-specific
// sensitive information configurable to the data in question.
type CustomInfoType struct {
	// Info type configuration. All custom info types must have configurations
	// that do not conflict with built-in info types or other custom info types.
	InfoType *InfoType `protobuf:"bytes,1,opt,name=info_type,json=infoType" json:"info_type,omitempty"`
	// Likelihood to return for this custom info type. This base value can be
	// altered by a detection rule if the finding meets the criteria specified by
	// the rule. Defaults to `VERY_LIKELY` if not specified.
	Likelihood Likelihood `protobuf:"varint,6,opt,name=likelihood,enum=google.privacy.dlp.v2beta2.Likelihood" json:"likelihood,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*CustomInfoType_Dictionary_
	//	*CustomInfoType_Regex_
	//	*CustomInfoType_SurrogateType_
	Type isCustomInfoType_Type `protobuf_oneof:"type"`
	// Set of detection rules to apply to all findings of this custom info type.
	// Rules are applied in order that they are specified. Not supported for the
	// `surrogate_type` custom info type.
	DetectionRules []*CustomInfoType_DetectionRule `protobuf:"bytes,7,rep,name=detection_rules,json=detectionRules" json:"detection_rules,omitempty"`
}

func (m *CustomInfoType) Reset()                    { *m = CustomInfoType{} }
func (m *CustomInfoType) String() string            { return proto.CompactTextString(m) }
func (*CustomInfoType) ProtoMessage()               {}
func (*CustomInfoType) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type isCustomInfoType_Type interface {
	isCustomInfoType_Type()
}

type CustomInfoType_Dictionary_ struct {
	Dictionary *CustomInfoType_Dictionary `protobuf:"bytes,2,opt,name=dictionary,oneof"`
}
type CustomInfoType_Regex_ struct {
	Regex *CustomInfoType_Regex `protobuf:"bytes,3,opt,name=regex,oneof"`
}
type CustomInfoType_SurrogateType_ struct {
	SurrogateType *CustomInfoType_SurrogateType `protobuf:"bytes,4,opt,name=surrogate_type,json=surrogateType,oneof"`
}

func (*CustomInfoType_Dictionary_) isCustomInfoType_Type()    {}
func (*CustomInfoType_Regex_) isCustomInfoType_Type()         {}
func (*CustomInfoType_SurrogateType_) isCustomInfoType_Type() {}

func (m *CustomInfoType) GetType() isCustomInfoType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CustomInfoType) GetInfoType() *InfoType {
	if m != nil {
		return m.InfoType
	}
	return nil
}

func (m *CustomInfoType) GetLikelihood() Likelihood {
	if m != nil {
		return m.Likelihood
	}
	return Likelihood_LIKELIHOOD_UNSPECIFIED
}

func (m *CustomInfoType) GetDictionary() *CustomInfoType_Dictionary {
	if x, ok := m.GetType().(*CustomInfoType_Dictionary_); ok {
		return x.Dictionary
	}
	return nil
}

func (m *CustomInfoType) GetRegex() *CustomInfoType_Regex {
	if x, ok := m.GetType().(*CustomInfoType_Regex_); ok {
		return x.Regex
	}
	return nil
}

func (m *CustomInfoType) GetSurrogateType() *CustomInfoType_SurrogateType {
	if x, ok := m.GetType().(*CustomInfoType_SurrogateType_); ok {
		return x.SurrogateType
	}
	return nil
}

func (m *CustomInfoType) GetDetectionRules() []*CustomInfoType_DetectionRule {
	if m != nil {
		return m.DetectionRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CustomInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CustomInfoType_OneofMarshaler, _CustomInfoType_OneofUnmarshaler, _CustomInfoType_OneofSizer, []interface{}{
		(*CustomInfoType_Dictionary_)(nil),
		(*CustomInfoType_Regex_)(nil),
		(*CustomInfoType_SurrogateType_)(nil),
	}
}

func _CustomInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CustomInfoType)
	// type
	switch x := m.Type.(type) {
	case *CustomInfoType_Dictionary_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dictionary); err != nil {
			return err
		}
	case *CustomInfoType_Regex_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Regex); err != nil {
			return err
		}
	case *CustomInfoType_SurrogateType_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SurrogateType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CustomInfoType.Type has unexpected type %T", x)
	}
	return nil
}

func _CustomInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CustomInfoType)
	switch tag {
	case 2: // type.dictionary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomInfoType_Dictionary)
		err := b.DecodeMessage(msg)
		m.Type = &CustomInfoType_Dictionary_{msg}
		return true, err
	case 3: // type.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomInfoType_Regex)
		err := b.DecodeMessage(msg)
		m.Type = &CustomInfoType_Regex_{msg}
		return true, err
	case 4: // type.surrogate_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomInfoType_SurrogateType)
		err := b.DecodeMessage(msg)
		m.Type = &CustomInfoType_SurrogateType_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CustomInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CustomInfoType)
	// type
	switch x := m.Type.(type) {
	case *CustomInfoType_Dictionary_:
		s := proto.Size(x.Dictionary)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CustomInfoType_Regex_:
		s := proto.Size(x.Regex)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CustomInfoType_SurrogateType_:
		s := proto.Size(x.SurrogateType)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Custom information type based on a dictionary of words or phrases. This can
// be used to match sensitive information specific to the data, such as a list
// of employee IDs or job titles.
//
// Dictionary words are case-insensitive and all characters other than letters
// and digits in the unicode [Basic Multilingual
// Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
// will be replaced with whitespace when scanning for matches, so the
// dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
// "Sam, Johnson", and "Sam (Johnson)". Additionally, the characters
// surrounding any match must be of a different type than the adjacent
// characters within the word, so letters must be next to non-letters and
// digits next to non-digits. For example, the dictionary word "jen" will
// match the first three letters of the text "jen123" but will return no
// matches for "jennifer".
//
// Dictionary words containing a large number of characters that are not
// letters or digits may result in unexpected findings because such characters
// are treated as whitespace.
type CustomInfoType_Dictionary struct {
	// Types that are valid to be assigned to Source:
	//	*CustomInfoType_Dictionary_WordList_
	Source isCustomInfoType_Dictionary_Source `protobuf_oneof:"source"`
}

func (m *CustomInfoType_Dictionary) Reset()                    { *m = CustomInfoType_Dictionary{} }
func (m *CustomInfoType_Dictionary) String() string            { return proto.CompactTextString(m) }
func (*CustomInfoType_Dictionary) ProtoMessage()               {}
func (*CustomInfoType_Dictionary) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

type isCustomInfoType_Dictionary_Source interface {
	isCustomInfoType_Dictionary_Source()
}

type CustomInfoType_Dictionary_WordList_ struct {
	WordList *CustomInfoType_Dictionary_WordList `protobuf:"bytes,1,opt,name=word_list,json=wordList,oneof"`
}

func (*CustomInfoType_Dictionary_WordList_) isCustomInfoType_Dictionary_Source() {}

func (m *CustomInfoType_Dictionary) GetSource() isCustomInfoType_Dictionary_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *CustomInfoType_Dictionary) GetWordList() *CustomInfoType_Dictionary_WordList {
	if x, ok := m.GetSource().(*CustomInfoType_Dictionary_WordList_); ok {
		return x.WordList
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CustomInfoType_Dictionary) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CustomInfoType_Dictionary_OneofMarshaler, _CustomInfoType_Dictionary_OneofUnmarshaler, _CustomInfoType_Dictionary_OneofSizer, []interface{}{
		(*CustomInfoType_Dictionary_WordList_)(nil),
	}
}

func _CustomInfoType_Dictionary_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CustomInfoType_Dictionary)
	// source
	switch x := m.Source.(type) {
	case *CustomInfoType_Dictionary_WordList_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WordList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CustomInfoType_Dictionary.Source has unexpected type %T", x)
	}
	return nil
}

func _CustomInfoType_Dictionary_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CustomInfoType_Dictionary)
	switch tag {
	case 1: // source.word_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomInfoType_Dictionary_WordList)
		err := b.DecodeMessage(msg)
		m.Source = &CustomInfoType_Dictionary_WordList_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CustomInfoType_Dictionary_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CustomInfoType_Dictionary)
	// source
	switch x := m.Source.(type) {
	case *CustomInfoType_Dictionary_WordList_:
		s := proto.Size(x.WordList)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message defining a list of words or phrases to search for in the data.
type CustomInfoType_Dictionary_WordList struct {
	// Words or phrases defining the dictionary. The dictionary must contain
	// at least one phrase and every phrase must contain at least 2 characters
	// that are letters or digits. [required]
	Words []string `protobuf:"bytes,1,rep,name=words" json:"words,omitempty"`
}

func (m *CustomInfoType_Dictionary_WordList) Reset()         { *m = CustomInfoType_Dictionary_WordList{} }
func (m *CustomInfoType_Dictionary_WordList) String() string { return proto.CompactTextString(m) }
func (*CustomInfoType_Dictionary_WordList) ProtoMessage()    {}
func (*CustomInfoType_Dictionary_WordList) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 0, 0}
}

func (m *CustomInfoType_Dictionary_WordList) GetWords() []string {
	if m != nil {
		return m.Words
	}
	return nil
}

// Message defining a custom regular expression.
type CustomInfoType_Regex struct {
	// Pattern defining the regular expression.
	Pattern string `protobuf:"bytes,1,opt,name=pattern" json:"pattern,omitempty"`
}

func (m *CustomInfoType_Regex) Reset()                    { *m = CustomInfoType_Regex{} }
func (m *CustomInfoType_Regex) String() string            { return proto.CompactTextString(m) }
func (*CustomInfoType_Regex) ProtoMessage()               {}
func (*CustomInfoType_Regex) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 1} }

func (m *CustomInfoType_Regex) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

// Message for detecting output from deidentification transformations
// such as
// [`CryptoReplaceFfxFpeConfig`](/dlp/docs/reference/rest/v2beta1/content/deidentify#CryptoReplaceFfxFpeConfig).
// These types of transformations are
// those that perform pseudonymization, thereby producing a "surrogate" as
// output. This should be used in conjunction with a field on the
// transformation such as `surrogate_info_type`. This custom info type does
// not support the use of `detection_rules`.
type CustomInfoType_SurrogateType struct {
}

func (m *CustomInfoType_SurrogateType) Reset()                    { *m = CustomInfoType_SurrogateType{} }
func (m *CustomInfoType_SurrogateType) String() string            { return proto.CompactTextString(m) }
func (*CustomInfoType_SurrogateType) ProtoMessage()               {}
func (*CustomInfoType_SurrogateType) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 2} }

// Rule for modifying a custom info type to alter behavior under certain
// circumstances, depending on the specific details of the rule. Not supported
// for the `surrogate_type` custom info type.
type CustomInfoType_DetectionRule struct {
	// Types that are valid to be assigned to Type:
	//	*CustomInfoType_DetectionRule_HotwordRule_
	Type isCustomInfoType_DetectionRule_Type `protobuf_oneof:"type"`
}

func (m *CustomInfoType_DetectionRule) Reset()                    { *m = CustomInfoType_DetectionRule{} }
func (m *CustomInfoType_DetectionRule) String() string            { return proto.CompactTextString(m) }
func (*CustomInfoType_DetectionRule) ProtoMessage()               {}
func (*CustomInfoType_DetectionRule) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 3} }

type isCustomInfoType_DetectionRule_Type interface {
	isCustomInfoType_DetectionRule_Type()
}

type CustomInfoType_DetectionRule_HotwordRule_ struct {
	HotwordRule *CustomInfoType_DetectionRule_HotwordRule `protobuf:"bytes,1,opt,name=hotword_rule,json=hotwordRule,oneof"`
}

func (*CustomInfoType_DetectionRule_HotwordRule_) isCustomInfoType_DetectionRule_Type() {}

func (m *CustomInfoType_DetectionRule) GetType() isCustomInfoType_DetectionRule_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CustomInfoType_DetectionRule) GetHotwordRule() *CustomInfoType_DetectionRule_HotwordRule {
	if x, ok := m.GetType().(*CustomInfoType_DetectionRule_HotwordRule_); ok {
		return x.HotwordRule
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CustomInfoType_DetectionRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CustomInfoType_DetectionRule_OneofMarshaler, _CustomInfoType_DetectionRule_OneofUnmarshaler, _CustomInfoType_DetectionRule_OneofSizer, []interface{}{
		(*CustomInfoType_DetectionRule_HotwordRule_)(nil),
	}
}

func _CustomInfoType_DetectionRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CustomInfoType_DetectionRule)
	// type
	switch x := m.Type.(type) {
	case *CustomInfoType_DetectionRule_HotwordRule_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HotwordRule); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CustomInfoType_DetectionRule.Type has unexpected type %T", x)
	}
	return nil
}

func _CustomInfoType_DetectionRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CustomInfoType_DetectionRule)
	switch tag {
	case 1: // type.hotword_rule
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomInfoType_DetectionRule_HotwordRule)
		err := b.DecodeMessage(msg)
		m.Type = &CustomInfoType_DetectionRule_HotwordRule_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CustomInfoType_DetectionRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CustomInfoType_DetectionRule)
	// type
	switch x := m.Type.(type) {
	case *CustomInfoType_DetectionRule_HotwordRule_:
		s := proto.Size(x.HotwordRule)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message for specifying a window around a finding to apply a detection
// rule.
type CustomInfoType_DetectionRule_Proximity struct {
	// Number of characters before the finding to consider.
	WindowBefore int32 `protobuf:"varint,1,opt,name=window_before,json=windowBefore" json:"window_before,omitempty"`
	// Number of characters after the finding to consider.
	WindowAfter int32 `protobuf:"varint,2,opt,name=window_after,json=windowAfter" json:"window_after,omitempty"`
}

func (m *CustomInfoType_DetectionRule_Proximity) Reset() {
	*m = CustomInfoType_DetectionRule_Proximity{}
}
func (m *CustomInfoType_DetectionRule_Proximity) String() string { return proto.CompactTextString(m) }
func (*CustomInfoType_DetectionRule_Proximity) ProtoMessage()    {}
func (*CustomInfoType_DetectionRule_Proximity) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 3, 0}
}

func (m *CustomInfoType_DetectionRule_Proximity) GetWindowBefore() int32 {
	if m != nil {
		return m.WindowBefore
	}
	return 0
}

func (m *CustomInfoType_DetectionRule_Proximity) GetWindowAfter() int32 {
	if m != nil {
		return m.WindowAfter
	}
	return 0
}

// Message for specifying an adjustment to the likelihood of a finding as
// part of a detection rule.
type CustomInfoType_DetectionRule_LikelihoodAdjustment struct {
	// Types that are valid to be assigned to Adjustment:
	//	*CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood
	//	*CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood
	Adjustment isCustomInfoType_DetectionRule_LikelihoodAdjustment_Adjustment `protobuf_oneof:"adjustment"`
}

func (m *CustomInfoType_DetectionRule_LikelihoodAdjustment) Reset() {
	*m = CustomInfoType_DetectionRule_LikelihoodAdjustment{}
}
func (m *CustomInfoType_DetectionRule_LikelihoodAdjustment) String() string {
	return proto.CompactTextString(m)
}
func (*CustomInfoType_DetectionRule_LikelihoodAdjustment) ProtoMessage() {}
func (*CustomInfoType_DetectionRule_LikelihoodAdjustment) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 3, 1}
}

type isCustomInfoType_DetectionRule_LikelihoodAdjustment_Adjustment interface {
	isCustomInfoType_DetectionRule_LikelihoodAdjustment_Adjustment()
}

type CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood struct {
	FixedLikelihood Likelihood `protobuf:"varint,1,opt,name=fixed_likelihood,json=fixedLikelihood,enum=google.privacy.dlp.v2beta2.Likelihood,oneof"`
}
type CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood struct {
	RelativeLikelihood int32 `protobuf:"varint,2,opt,name=relative_likelihood,json=relativeLikelihood,oneof"`
}

func (*CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood) isCustomInfoType_DetectionRule_LikelihoodAdjustment_Adjustment() {
}
func (*CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood) isCustomInfoType_DetectionRule_LikelihoodAdjustment_Adjustment() {
}

func (m *CustomInfoType_DetectionRule_LikelihoodAdjustment) GetAdjustment() isCustomInfoType_DetectionRule_LikelihoodAdjustment_Adjustment {
	if m != nil {
		return m.Adjustment
	}
	return nil
}

func (m *CustomInfoType_DetectionRule_LikelihoodAdjustment) GetFixedLikelihood() Likelihood {
	if x, ok := m.GetAdjustment().(*CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood); ok {
		return x.FixedLikelihood
	}
	return Likelihood_LIKELIHOOD_UNSPECIFIED
}

func (m *CustomInfoType_DetectionRule_LikelihoodAdjustment) GetRelativeLikelihood() int32 {
	if x, ok := m.GetAdjustment().(*CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood); ok {
		return x.RelativeLikelihood
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CustomInfoType_DetectionRule_LikelihoodAdjustment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CustomInfoType_DetectionRule_LikelihoodAdjustment_OneofMarshaler, _CustomInfoType_DetectionRule_LikelihoodAdjustment_OneofUnmarshaler, _CustomInfoType_DetectionRule_LikelihoodAdjustment_OneofSizer, []interface{}{
		(*CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood)(nil),
		(*CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood)(nil),
	}
}

func _CustomInfoType_DetectionRule_LikelihoodAdjustment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CustomInfoType_DetectionRule_LikelihoodAdjustment)
	// adjustment
	switch x := m.Adjustment.(type) {
	case *CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.FixedLikelihood))
	case *CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.RelativeLikelihood))
	case nil:
	default:
		return fmt.Errorf("CustomInfoType_DetectionRule_LikelihoodAdjustment.Adjustment has unexpected type %T", x)
	}
	return nil
}

func _CustomInfoType_DetectionRule_LikelihoodAdjustment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CustomInfoType_DetectionRule_LikelihoodAdjustment)
	switch tag {
	case 1: // adjustment.fixed_likelihood
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Adjustment = &CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood{Likelihood(x)}
		return true, err
	case 2: // adjustment.relative_likelihood
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Adjustment = &CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _CustomInfoType_DetectionRule_LikelihoodAdjustment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CustomInfoType_DetectionRule_LikelihoodAdjustment)
	// adjustment
	switch x := m.Adjustment.(type) {
	case *CustomInfoType_DetectionRule_LikelihoodAdjustment_FixedLikelihood:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.FixedLikelihood))
	case *CustomInfoType_DetectionRule_LikelihoodAdjustment_RelativeLikelihood:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.RelativeLikelihood))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Detection rule that adjusts the likelihood of findings within a certain
// proximity of hotwords.
type CustomInfoType_DetectionRule_HotwordRule struct {
	// Regex pattern defining what qualifies as a hotword.
	HotwordRegex *CustomInfoType_Regex `protobuf:"bytes,1,opt,name=hotword_regex,json=hotwordRegex" json:"hotword_regex,omitempty"`
	// Proximity of the finding within which the entire hotword must reside.
	// The total length of the window cannot exceed 1000 characters. Note that
	// the finding itself will be included in the window, so that hotwords may
	// be used to match substrings of the finding itself. For example, the
	// certainty of a phone number regex "\(\d{3}\) \d{3}-\d{4}" could be
	// adjusted upwards if the area code is known to be the local area code of
	// a company office using the hotword regex "\(xxx\)", where "xxx"
	// is the area code in question.
	Proximity *CustomInfoType_DetectionRule_Proximity `protobuf:"bytes,2,opt,name=proximity" json:"proximity,omitempty"`
	// Likelihood adjustment to apply to all matching findings.
	LikelihoodAdjustment *CustomInfoType_DetectionRule_LikelihoodAdjustment `protobuf:"bytes,3,opt,name=likelihood_adjustment,json=likelihoodAdjustment" json:"likelihood_adjustment,omitempty"`
}

func (m *CustomInfoType_DetectionRule_HotwordRule) Reset() {
	*m = CustomInfoType_DetectionRule_HotwordRule{}
}
func (m *CustomInfoType_DetectionRule_HotwordRule) String() string { return proto.CompactTextString(m) }
func (*CustomInfoType_DetectionRule_HotwordRule) ProtoMessage()    {}
func (*CustomInfoType_DetectionRule_HotwordRule) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{1, 3, 2}
}

func (m *CustomInfoType_DetectionRule_HotwordRule) GetHotwordRegex() *CustomInfoType_Regex {
	if m != nil {
		return m.HotwordRegex
	}
	return nil
}

func (m *CustomInfoType_DetectionRule_HotwordRule) GetProximity() *CustomInfoType_DetectionRule_Proximity {
	if m != nil {
		return m.Proximity
	}
	return nil
}

func (m *CustomInfoType_DetectionRule_HotwordRule) GetLikelihoodAdjustment() *CustomInfoType_DetectionRule_LikelihoodAdjustment {
	if m != nil {
		return m.LikelihoodAdjustment
	}
	return nil
}

// General identifier of a data field in a storage service.
type FieldId struct {
	// Name describing the field.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *FieldId) Reset()                    { *m = FieldId{} }
func (m *FieldId) String() string            { return proto.CompactTextString(m) }
func (*FieldId) ProtoMessage()               {}
func (*FieldId) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *FieldId) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Datastore partition ID.
// A partition ID identifies a grouping of entities. The grouping is always
// by project and namespace, however the namespace ID may be empty.
//
// A partition ID contains several dimensions:
// project ID and namespace ID.
type PartitionId struct {
	// The ID of the project to which the entities belong.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// If not empty, the ID of the namespace to which the entities belong.
	NamespaceId string `protobuf:"bytes,4,opt,name=namespace_id,json=namespaceId" json:"namespace_id,omitempty"`
}

func (m *PartitionId) Reset()                    { *m = PartitionId{} }
func (m *PartitionId) String() string            { return proto.CompactTextString(m) }
func (*PartitionId) ProtoMessage()               {}
func (*PartitionId) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *PartitionId) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *PartitionId) GetNamespaceId() string {
	if m != nil {
		return m.NamespaceId
	}
	return ""
}

// A representation of a Datastore kind.
type KindExpression struct {
	// The name of the kind.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *KindExpression) Reset()                    { *m = KindExpression{} }
func (m *KindExpression) String() string            { return proto.CompactTextString(m) }
func (*KindExpression) ProtoMessage()               {}
func (*KindExpression) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *KindExpression) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Options defining a data set within Google Cloud Datastore.
type DatastoreOptions struct {
	// A partition ID identifies a grouping of entities. The grouping is always
	// by project and namespace, however the namespace ID may be empty.
	PartitionId *PartitionId `protobuf:"bytes,1,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// The kind to process.
	Kind *KindExpression `protobuf:"bytes,2,opt,name=kind" json:"kind,omitempty"`
}

func (m *DatastoreOptions) Reset()                    { *m = DatastoreOptions{} }
func (m *DatastoreOptions) String() string            { return proto.CompactTextString(m) }
func (*DatastoreOptions) ProtoMessage()               {}
func (*DatastoreOptions) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *DatastoreOptions) GetPartitionId() *PartitionId {
	if m != nil {
		return m.PartitionId
	}
	return nil
}

func (m *DatastoreOptions) GetKind() *KindExpression {
	if m != nil {
		return m.Kind
	}
	return nil
}

// Options defining a file or a set of files (path ending with *) within
// a Google Cloud Storage bucket.
type CloudStorageOptions struct {
	FileSet *CloudStorageOptions_FileSet `protobuf:"bytes,1,opt,name=file_set,json=fileSet" json:"file_set,omitempty"`
	// Max number of bytes to scan from a file. If a scanned file's size is bigger
	// than this value then the rest of the bytes are omitted.
	BytesLimitPerFile int64 `protobuf:"varint,4,opt,name=bytes_limit_per_file,json=bytesLimitPerFile" json:"bytes_limit_per_file,omitempty"`
}

func (m *CloudStorageOptions) Reset()                    { *m = CloudStorageOptions{} }
func (m *CloudStorageOptions) String() string            { return proto.CompactTextString(m) }
func (*CloudStorageOptions) ProtoMessage()               {}
func (*CloudStorageOptions) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *CloudStorageOptions) GetFileSet() *CloudStorageOptions_FileSet {
	if m != nil {
		return m.FileSet
	}
	return nil
}

func (m *CloudStorageOptions) GetBytesLimitPerFile() int64 {
	if m != nil {
		return m.BytesLimitPerFile
	}
	return 0
}

// Set of files to scan.
type CloudStorageOptions_FileSet struct {
	// The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
	// path is allowed.
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
}

func (m *CloudStorageOptions_FileSet) Reset()                    { *m = CloudStorageOptions_FileSet{} }
func (m *CloudStorageOptions_FileSet) String() string            { return proto.CompactTextString(m) }
func (*CloudStorageOptions_FileSet) ProtoMessage()               {}
func (*CloudStorageOptions_FileSet) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6, 0} }

func (m *CloudStorageOptions_FileSet) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Options defining BigQuery table and row identifiers.
type BigQueryOptions struct {
	// Complete BigQuery table reference.
	TableReference *BigQueryTable `protobuf:"bytes,1,opt,name=table_reference,json=tableReference" json:"table_reference,omitempty"`
	// References to fields uniquely identifying rows within the table.
	// Nested fields in the format, like `person.birthdate.year`, are allowed.
	IdentifyingFields []*FieldId `protobuf:"bytes,2,rep,name=identifying_fields,json=identifyingFields" json:"identifying_fields,omitempty"`
}

func (m *BigQueryOptions) Reset()                    { *m = BigQueryOptions{} }
func (m *BigQueryOptions) String() string            { return proto.CompactTextString(m) }
func (*BigQueryOptions) ProtoMessage()               {}
func (*BigQueryOptions) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *BigQueryOptions) GetTableReference() *BigQueryTable {
	if m != nil {
		return m.TableReference
	}
	return nil
}

func (m *BigQueryOptions) GetIdentifyingFields() []*FieldId {
	if m != nil {
		return m.IdentifyingFields
	}
	return nil
}

// Shared message indicating Cloud storage type.
type StorageConfig struct {
	// Types that are valid to be assigned to Type:
	//	*StorageConfig_DatastoreOptions
	//	*StorageConfig_CloudStorageOptions
	//	*StorageConfig_BigQueryOptions
	Type           isStorageConfig_Type          `protobuf_oneof:"type"`
	TimespanConfig *StorageConfig_TimespanConfig `protobuf:"bytes,6,opt,name=timespan_config,json=timespanConfig" json:"timespan_config,omitempty"`
}

func (m *StorageConfig) Reset()                    { *m = StorageConfig{} }
func (m *StorageConfig) String() string            { return proto.CompactTextString(m) }
func (*StorageConfig) ProtoMessage()               {}
func (*StorageConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

type isStorageConfig_Type interface {
	isStorageConfig_Type()
}

type StorageConfig_DatastoreOptions struct {
	DatastoreOptions *DatastoreOptions `protobuf:"bytes,2,opt,name=datastore_options,json=datastoreOptions,oneof"`
}
type StorageConfig_CloudStorageOptions struct {
	CloudStorageOptions *CloudStorageOptions `protobuf:"bytes,3,opt,name=cloud_storage_options,json=cloudStorageOptions,oneof"`
}
type StorageConfig_BigQueryOptions struct {
	BigQueryOptions *BigQueryOptions `protobuf:"bytes,4,opt,name=big_query_options,json=bigQueryOptions,oneof"`
}

func (*StorageConfig_DatastoreOptions) isStorageConfig_Type()    {}
func (*StorageConfig_CloudStorageOptions) isStorageConfig_Type() {}
func (*StorageConfig_BigQueryOptions) isStorageConfig_Type()     {}

func (m *StorageConfig) GetType() isStorageConfig_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *StorageConfig) GetDatastoreOptions() *DatastoreOptions {
	if x, ok := m.GetType().(*StorageConfig_DatastoreOptions); ok {
		return x.DatastoreOptions
	}
	return nil
}

func (m *StorageConfig) GetCloudStorageOptions() *CloudStorageOptions {
	if x, ok := m.GetType().(*StorageConfig_CloudStorageOptions); ok {
		return x.CloudStorageOptions
	}
	return nil
}

func (m *StorageConfig) GetBigQueryOptions() *BigQueryOptions {
	if x, ok := m.GetType().(*StorageConfig_BigQueryOptions); ok {
		return x.BigQueryOptions
	}
	return nil
}

func (m *StorageConfig) GetTimespanConfig() *StorageConfig_TimespanConfig {
	if m != nil {
		return m.TimespanConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageConfig_OneofMarshaler, _StorageConfig_OneofUnmarshaler, _StorageConfig_OneofSizer, []interface{}{
		(*StorageConfig_DatastoreOptions)(nil),
		(*StorageConfig_CloudStorageOptions)(nil),
		(*StorageConfig_BigQueryOptions)(nil),
	}
}

func _StorageConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageConfig)
	// type
	switch x := m.Type.(type) {
	case *StorageConfig_DatastoreOptions:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DatastoreOptions); err != nil {
			return err
		}
	case *StorageConfig_CloudStorageOptions:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudStorageOptions); err != nil {
			return err
		}
	case *StorageConfig_BigQueryOptions:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BigQueryOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StorageConfig.Type has unexpected type %T", x)
	}
	return nil
}

func _StorageConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageConfig)
	switch tag {
	case 2: // type.datastore_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatastoreOptions)
		err := b.DecodeMessage(msg)
		m.Type = &StorageConfig_DatastoreOptions{msg}
		return true, err
	case 3: // type.cloud_storage_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudStorageOptions)
		err := b.DecodeMessage(msg)
		m.Type = &StorageConfig_CloudStorageOptions{msg}
		return true, err
	case 4: // type.big_query_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BigQueryOptions)
		err := b.DecodeMessage(msg)
		m.Type = &StorageConfig_BigQueryOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StorageConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageConfig)
	// type
	switch x := m.Type.(type) {
	case *StorageConfig_DatastoreOptions:
		s := proto.Size(x.DatastoreOptions)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageConfig_CloudStorageOptions:
		s := proto.Size(x.CloudStorageOptions)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageConfig_BigQueryOptions:
		s := proto.Size(x.BigQueryOptions)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Configuration of the timespan of the items to include in scanning.
// Currently only supported when inspecting Google Cloud Storage and BigQuery.
type StorageConfig_TimespanConfig struct {
	// Exclude files older than this value.
	StartTime *google_protobuf1.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Exclude files newer than this value.
	// If set to zero, no upper time limit is applied.
	EndTime *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// When the job is started by a JobTrigger we will automatically figure out
	// a valid start_time to avoid scanning files that have not been modified
	// since the last time the JobTrigger executed. This will be based on the
	// time of the execution of the last run of the JobTrigger.
	EnableAutoPopulationOfTimespanConfig bool `protobuf:"varint,4,opt,name=enable_auto_population_of_timespan_config,json=enableAutoPopulationOfTimespanConfig" json:"enable_auto_population_of_timespan_config,omitempty"`
}

func (m *StorageConfig_TimespanConfig) Reset()                    { *m = StorageConfig_TimespanConfig{} }
func (m *StorageConfig_TimespanConfig) String() string            { return proto.CompactTextString(m) }
func (*StorageConfig_TimespanConfig) ProtoMessage()               {}
func (*StorageConfig_TimespanConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8, 0} }

func (m *StorageConfig_TimespanConfig) GetStartTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *StorageConfig_TimespanConfig) GetEndTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *StorageConfig_TimespanConfig) GetEnableAutoPopulationOfTimespanConfig() bool {
	if m != nil {
		return m.EnableAutoPopulationOfTimespanConfig
	}
	return false
}

// Row key for identifying a record in BigQuery table.
type BigQueryKey struct {
	// Complete BigQuery table reference.
	TableReference *BigQueryTable `protobuf:"bytes,1,opt,name=table_reference,json=tableReference" json:"table_reference,omitempty"`
	// Absolute number of the row from the beginning of the table at the time
	// of scanning.
	RowNumber int64 `protobuf:"varint,2,opt,name=row_number,json=rowNumber" json:"row_number,omitempty"`
}

func (m *BigQueryKey) Reset()                    { *m = BigQueryKey{} }
func (m *BigQueryKey) String() string            { return proto.CompactTextString(m) }
func (*BigQueryKey) ProtoMessage()               {}
func (*BigQueryKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *BigQueryKey) GetTableReference() *BigQueryTable {
	if m != nil {
		return m.TableReference
	}
	return nil
}

func (m *BigQueryKey) GetRowNumber() int64 {
	if m != nil {
		return m.RowNumber
	}
	return 0
}

// Record key for a finding in a Cloud Storage file.
type CloudStorageKey struct {
	// Path to the file.
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath" json:"file_path,omitempty"`
	// Byte offset of the referenced data in the file.
	StartOffset int64 `protobuf:"varint,2,opt,name=start_offset,json=startOffset" json:"start_offset,omitempty"`
}

func (m *CloudStorageKey) Reset()                    { *m = CloudStorageKey{} }
func (m *CloudStorageKey) String() string            { return proto.CompactTextString(m) }
func (*CloudStorageKey) ProtoMessage()               {}
func (*CloudStorageKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *CloudStorageKey) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *CloudStorageKey) GetStartOffset() int64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

// Record key for a finding in Cloud Datastore.
type DatastoreKey struct {
	// Datastore entity key.
	EntityKey *Key `protobuf:"bytes,1,opt,name=entity_key,json=entityKey" json:"entity_key,omitempty"`
}

func (m *DatastoreKey) Reset()                    { *m = DatastoreKey{} }
func (m *DatastoreKey) String() string            { return proto.CompactTextString(m) }
func (*DatastoreKey) ProtoMessage()               {}
func (*DatastoreKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *DatastoreKey) GetEntityKey() *Key {
	if m != nil {
		return m.EntityKey
	}
	return nil
}

// A unique identifier for a Datastore entity.
// If a key's partition ID or any of its path kinds or names are
// reserved/read-only, the key is reserved/read-only.
// A reserved/read-only key is forbidden in certain documented contexts.
type Key struct {
	// Entities are partitioned into subsets, currently identified by a project
	// ID and namespace ID.
	// Queries are scoped to a single partition.
	PartitionId *PartitionId `protobuf:"bytes,1,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// The entity path.
	// An entity path consists of one or more elements composed of a kind and a
	// string or numerical identifier, which identify entities. The first
	// element identifies a _root entity_, the second element identifies
	// a _child_ of the root entity, the third element identifies a child of the
	// second entity, and so forth. The entities identified by all prefixes of
	// the path are called the element's _ancestors_.
	//
	// A path can never be empty, and a path can have at most 100 elements.
	Path []*Key_PathElement `protobuf:"bytes,2,rep,name=path" json:"path,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *Key) GetPartitionId() *PartitionId {
	if m != nil {
		return m.PartitionId
	}
	return nil
}

func (m *Key) GetPath() []*Key_PathElement {
	if m != nil {
		return m.Path
	}
	return nil
}

// A (kind, ID/name) pair used to construct a key path.
//
// If either name or ID is set, the element is complete.
// If neither is set, the element is incomplete.
type Key_PathElement struct {
	// The kind of the entity.
	// A kind matching regex `__.*__` is reserved/read-only.
	// A kind must not contain more than 1500 bytes when UTF-8 encoded.
	// Cannot be `""`.
	Kind string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	// The type of ID.
	//
	// Types that are valid to be assigned to IdType:
	//	*Key_PathElement_Id
	//	*Key_PathElement_Name
	IdType isKey_PathElement_IdType `protobuf_oneof:"id_type"`
}

func (m *Key_PathElement) Reset()                    { *m = Key_PathElement{} }
func (m *Key_PathElement) String() string            { return proto.CompactTextString(m) }
func (*Key_PathElement) ProtoMessage()               {}
func (*Key_PathElement) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12, 0} }

type isKey_PathElement_IdType interface {
	isKey_PathElement_IdType()
}

type Key_PathElement_Id struct {
	Id int64 `protobuf:"varint,2,opt,name=id,oneof"`
}
type Key_PathElement_Name struct {
	Name string `protobuf:"bytes,3,opt,name=name,oneof"`
}

func (*Key_PathElement_Id) isKey_PathElement_IdType()   {}
func (*Key_PathElement_Name) isKey_PathElement_IdType() {}

func (m *Key_PathElement) GetIdType() isKey_PathElement_IdType {
	if m != nil {
		return m.IdType
	}
	return nil
}

func (m *Key_PathElement) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Key_PathElement) GetId() int64 {
	if x, ok := m.GetIdType().(*Key_PathElement_Id); ok {
		return x.Id
	}
	return 0
}

func (m *Key_PathElement) GetName() string {
	if x, ok := m.GetIdType().(*Key_PathElement_Name); ok {
		return x.Name
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Key_PathElement) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Key_PathElement_OneofMarshaler, _Key_PathElement_OneofUnmarshaler, _Key_PathElement_OneofSizer, []interface{}{
		(*Key_PathElement_Id)(nil),
		(*Key_PathElement_Name)(nil),
	}
}

func _Key_PathElement_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Key_PathElement)
	// id_type
	switch x := m.IdType.(type) {
	case *Key_PathElement_Id:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Id))
	case *Key_PathElement_Name:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case nil:
	default:
		return fmt.Errorf("Key_PathElement.IdType has unexpected type %T", x)
	}
	return nil
}

func _Key_PathElement_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Key_PathElement)
	switch tag {
	case 2: // id_type.id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.IdType = &Key_PathElement_Id{int64(x)}
		return true, err
	case 3: // id_type.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.IdType = &Key_PathElement_Name{x}
		return true, err
	default:
		return false, nil
	}
}

func _Key_PathElement_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Key_PathElement)
	// id_type
	switch x := m.IdType.(type) {
	case *Key_PathElement_Id:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Id))
	case *Key_PathElement_Name:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message for a unique key indicating a record that contains a finding.
type RecordKey struct {
	// Types that are valid to be assigned to Type:
	//	*RecordKey_CloudStorageKey
	//	*RecordKey_DatastoreKey
	//	*RecordKey_BigQueryKey
	Type isRecordKey_Type `protobuf_oneof:"type"`
}

func (m *RecordKey) Reset()                    { *m = RecordKey{} }
func (m *RecordKey) String() string            { return proto.CompactTextString(m) }
func (*RecordKey) ProtoMessage()               {}
func (*RecordKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

type isRecordKey_Type interface {
	isRecordKey_Type()
}

type RecordKey_CloudStorageKey struct {
	CloudStorageKey *CloudStorageKey `protobuf:"bytes,1,opt,name=cloud_storage_key,json=cloudStorageKey,oneof"`
}
type RecordKey_DatastoreKey struct {
	DatastoreKey *DatastoreKey `protobuf:"bytes,2,opt,name=datastore_key,json=datastoreKey,oneof"`
}
type RecordKey_BigQueryKey struct {
	BigQueryKey *BigQueryKey `protobuf:"bytes,3,opt,name=big_query_key,json=bigQueryKey,oneof"`
}

func (*RecordKey_CloudStorageKey) isRecordKey_Type() {}
func (*RecordKey_DatastoreKey) isRecordKey_Type()    {}
func (*RecordKey_BigQueryKey) isRecordKey_Type()     {}

func (m *RecordKey) GetType() isRecordKey_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RecordKey) GetCloudStorageKey() *CloudStorageKey {
	if x, ok := m.GetType().(*RecordKey_CloudStorageKey); ok {
		return x.CloudStorageKey
	}
	return nil
}

func (m *RecordKey) GetDatastoreKey() *DatastoreKey {
	if x, ok := m.GetType().(*RecordKey_DatastoreKey); ok {
		return x.DatastoreKey
	}
	return nil
}

func (m *RecordKey) GetBigQueryKey() *BigQueryKey {
	if x, ok := m.GetType().(*RecordKey_BigQueryKey); ok {
		return x.BigQueryKey
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RecordKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RecordKey_OneofMarshaler, _RecordKey_OneofUnmarshaler, _RecordKey_OneofSizer, []interface{}{
		(*RecordKey_CloudStorageKey)(nil),
		(*RecordKey_DatastoreKey)(nil),
		(*RecordKey_BigQueryKey)(nil),
	}
}

func _RecordKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RecordKey)
	// type
	switch x := m.Type.(type) {
	case *RecordKey_CloudStorageKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudStorageKey); err != nil {
			return err
		}
	case *RecordKey_DatastoreKey:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DatastoreKey); err != nil {
			return err
		}
	case *RecordKey_BigQueryKey:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BigQueryKey); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RecordKey.Type has unexpected type %T", x)
	}
	return nil
}

func _RecordKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RecordKey)
	switch tag {
	case 1: // type.cloud_storage_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudStorageKey)
		err := b.DecodeMessage(msg)
		m.Type = &RecordKey_CloudStorageKey{msg}
		return true, err
	case 2: // type.datastore_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatastoreKey)
		err := b.DecodeMessage(msg)
		m.Type = &RecordKey_DatastoreKey{msg}
		return true, err
	case 3: // type.big_query_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BigQueryKey)
		err := b.DecodeMessage(msg)
		m.Type = &RecordKey_BigQueryKey{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RecordKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RecordKey)
	// type
	switch x := m.Type.(type) {
	case *RecordKey_CloudStorageKey:
		s := proto.Size(x.CloudStorageKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RecordKey_DatastoreKey:
		s := proto.Size(x.DatastoreKey)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RecordKey_BigQueryKey:
		s := proto.Size(x.BigQueryKey)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message defining the location of a BigQuery table. A table is uniquely
// identified  by its project_id, dataset_id, and table_name. Within a query
// a table is often referenced with a string in the format of:
// `<project_id>:<dataset_id>.<table_id>` or
// `<project_id>.<dataset_id>.<table_id>`.
type BigQueryTable struct {
	// The Google Cloud Platform project ID of the project containing the table.
	// If omitted, project ID is inferred from the API call.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// Dataset ID of the table.
	DatasetId string `protobuf:"bytes,2,opt,name=dataset_id,json=datasetId" json:"dataset_id,omitempty"`
	// Name of the table.
	TableId string `protobuf:"bytes,3,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
}

func (m *BigQueryTable) Reset()                    { *m = BigQueryTable{} }
func (m *BigQueryTable) String() string            { return proto.CompactTextString(m) }
func (*BigQueryTable) ProtoMessage()               {}
func (*BigQueryTable) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *BigQueryTable) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *BigQueryTable) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *BigQueryTable) GetTableId() string {
	if m != nil {
		return m.TableId
	}
	return ""
}

// An entity in a dataset is a field or set of fields that correspond to a
// single person. For example, in medical records the `EntityId` might be
// a patient identifier, or for financial records it might be an account
// identifier. This message is used when generalizations or analysis must be
// consistent across multiple rows pertaining to the same entity.
type EntityId struct {
	// Composite key indicating which field contains the entity identifier.
	Field *FieldId `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
}

func (m *EntityId) Reset()                    { *m = EntityId{} }
func (m *EntityId) String() string            { return proto.CompactTextString(m) }
func (*EntityId) ProtoMessage()               {}
func (*EntityId) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *EntityId) GetField() *FieldId {
	if m != nil {
		return m.Field
	}
	return nil
}

func init() {
	proto.RegisterType((*InfoType)(nil), "google.privacy.dlp.v2beta2.InfoType")
	proto.RegisterType((*CustomInfoType)(nil), "google.privacy.dlp.v2beta2.CustomInfoType")
	proto.RegisterType((*CustomInfoType_Dictionary)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.Dictionary")
	proto.RegisterType((*CustomInfoType_Dictionary_WordList)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.Dictionary.WordList")
	proto.RegisterType((*CustomInfoType_Regex)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.Regex")
	proto.RegisterType((*CustomInfoType_SurrogateType)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.SurrogateType")
	proto.RegisterType((*CustomInfoType_DetectionRule)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.DetectionRule")
	proto.RegisterType((*CustomInfoType_DetectionRule_Proximity)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.DetectionRule.Proximity")
	proto.RegisterType((*CustomInfoType_DetectionRule_LikelihoodAdjustment)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.DetectionRule.LikelihoodAdjustment")
	proto.RegisterType((*CustomInfoType_DetectionRule_HotwordRule)(nil), "google.privacy.dlp.v2beta2.CustomInfoType.DetectionRule.HotwordRule")
	proto.RegisterType((*FieldId)(nil), "google.privacy.dlp.v2beta2.FieldId")
	proto.RegisterType((*PartitionId)(nil), "google.privacy.dlp.v2beta2.PartitionId")
	proto.RegisterType((*KindExpression)(nil), "google.privacy.dlp.v2beta2.KindExpression")
	proto.RegisterType((*DatastoreOptions)(nil), "google.privacy.dlp.v2beta2.DatastoreOptions")
	proto.RegisterType((*CloudStorageOptions)(nil), "google.privacy.dlp.v2beta2.CloudStorageOptions")
	proto.RegisterType((*CloudStorageOptions_FileSet)(nil), "google.privacy.dlp.v2beta2.CloudStorageOptions.FileSet")
	proto.RegisterType((*BigQueryOptions)(nil), "google.privacy.dlp.v2beta2.BigQueryOptions")
	proto.RegisterType((*StorageConfig)(nil), "google.privacy.dlp.v2beta2.StorageConfig")
	proto.RegisterType((*StorageConfig_TimespanConfig)(nil), "google.privacy.dlp.v2beta2.StorageConfig.TimespanConfig")
	proto.RegisterType((*BigQueryKey)(nil), "google.privacy.dlp.v2beta2.BigQueryKey")
	proto.RegisterType((*CloudStorageKey)(nil), "google.privacy.dlp.v2beta2.CloudStorageKey")
	proto.RegisterType((*DatastoreKey)(nil), "google.privacy.dlp.v2beta2.DatastoreKey")
	proto.RegisterType((*Key)(nil), "google.privacy.dlp.v2beta2.Key")
	proto.RegisterType((*Key_PathElement)(nil), "google.privacy.dlp.v2beta2.Key.PathElement")
	proto.RegisterType((*RecordKey)(nil), "google.privacy.dlp.v2beta2.RecordKey")
	proto.RegisterType((*BigQueryTable)(nil), "google.privacy.dlp.v2beta2.BigQueryTable")
	proto.RegisterType((*EntityId)(nil), "google.privacy.dlp.v2beta2.EntityId")
	proto.RegisterEnum("google.privacy.dlp.v2beta2.Likelihood", Likelihood_name, Likelihood_value)
}

func init() { proto.RegisterFile("google/privacy/dlp/v2beta2/storage.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 1585 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x72, 0x23, 0x49,
	0x11, 0x56, 0xeb, 0xc7, 0x96, 0x52, 0xd6, 0x8f, 0x6b, 0xbc, 0x84, 0xe8, 0xc5, 0xbb, 0x5e, 0xed,
	0x04, 0x78, 0x77, 0x08, 0x09, 0x4c, 0x6c, 0xc0, 0x06, 0xc1, 0x10, 0x96, 0x25, 0x23, 0x61, 0xaf,
	0xa5, 0x2d, 0x79, 0x66, 0xc2, 0x30, 0x44, 0xd3, 0x52, 0x55, 0xcb, 0x35, 0xd3, 0xea, 0x6a, 0xba,
	0x4b, 0x63, 0xeb, 0x46, 0xf0, 0x00, 0x5c, 0xb9, 0x71, 0xe1, 0x46, 0x70, 0xe1, 0x44, 0xf0, 0x0a,
	0x70, 0xe5, 0xc6, 0x0b, 0xf0, 0x06, 0x5c, 0x89, 0xaa, 0xea, 0x6e, 0x49, 0xc6, 0xc8, 0x3f, 0xc1,
	0x9e, 0xdc, 0x99, 0x95, 0xf9, 0x55, 0xfe, 0x67, 0x59, 0xb0, 0x3f, 0xe1, 0x7c, 0xe2, 0xd2, 0xa6,
	0x1f, 0xb0, 0x77, 0xf6, 0x78, 0xde, 0x24, 0xae, 0xdf, 0x7c, 0x77, 0x30, 0xa2, 0xc2, 0x3e, 0x68,
	0x86, 0x82, 0x07, 0xf6, 0x84, 0x36, 0xfc, 0x80, 0x0b, 0x8e, 0x4c, 0x2d, 0xd9, 0x88, 0x24, 0x1b,
	0xc4, 0xf5, 0x1b, 0x91, 0xa4, 0xf9, 0x8d, 0x08, 0xc5, 0xf6, 0x59, 0xd3, 0xf6, 0x3c, 0x2e, 0x6c,
	0xc1, 0xb8, 0x17, 0x6a, 0x4d, 0xf3, 0xc3, 0xe4, 0x0e, 0x2e, 0xf8, 0x68, 0xe6, 0x34, 0x05, 0x9b,
	0xd2, 0x50, 0xd8, 0x53, 0x5f, 0x0b, 0xd4, 0x3f, 0x80, 0x7c, 0xcf, 0x73, 0xf8, 0xf9, 0xdc, 0xa7,
	0x08, 0x41, 0xd6, 0xb3, 0xa7, 0xb4, 0x66, 0xec, 0x19, 0xfb, 0x05, 0xac, 0xbe, 0xeb, 0x7f, 0x2e,
	0x42, 0xf9, 0x68, 0x16, 0x0a, 0x3e, 0x4d, 0xc4, 0x0e, 0xa1, 0xc0, 0x3c, 0x87, 0x5b, 0x62, 0xee,
	0x6b, 0xd9, 0xe2, 0xc1, 0xd3, 0xc6, 0xff, 0xb6, 0xb0, 0x11, 0x2b, 0xe2, 0x3c, 0x8b, 0x21, 0x8e,
	0x01, 0x5c, 0xf6, 0x96, 0xba, 0xec, 0x92, 0x73, 0x52, 0xdb, 0xd8, 0x33, 0xf6, 0xcb, 0x07, 0xdf,
	0x5c, 0x87, 0x71, 0x9a, 0x48, 0xe3, 0x25, 0x4d, 0xf4, 0x0a, 0x80, 0xb0, 0xb1, 0x74, 0xd8, 0x0e,
	0xe6, 0xb5, 0xb4, 0xb2, 0xe5, 0xb3, 0x75, 0x38, 0xab, 0xae, 0x34, 0xda, 0x89, 0x72, 0x37, 0x85,
	0x97, 0xa0, 0x50, 0x17, 0x72, 0x01, 0x9d, 0xd0, 0xeb, 0x5a, 0x46, 0x61, 0x7e, 0xe7, 0x01, 0x98,
	0x58, 0xea, 0x75, 0x53, 0x58, 0x03, 0x20, 0x1b, 0xca, 0xe1, 0x2c, 0x08, 0xf8, 0xc4, 0x16, 0x54,
	0x87, 0x2c, 0xab, 0x20, 0x7f, 0xf0, 0x00, 0xc8, 0x61, 0x0c, 0x20, 0xa9, 0x6e, 0x0a, 0x97, 0xc2,
	0x65, 0x06, 0xb2, 0xa1, 0x42, 0xa8, 0xa0, 0xca, 0x78, 0x2b, 0x98, 0xb9, 0x34, 0xac, 0x6d, 0xee,
	0x65, 0x1e, 0x78, 0x47, 0x3b, 0x46, 0xc0, 0x33, 0x97, 0xe2, 0x32, 0x59, 0x26, 0x43, 0xf3, 0x77,
	0x06, 0xc0, 0x22, 0x58, 0xe8, 0x17, 0x50, 0xb8, 0xe2, 0x01, 0xb1, 0x5c, 0x16, 0x8a, 0xa8, 0x04,
	0x9e, 0x3f, 0x2a, 0xec, 0x8d, 0x57, 0x3c, 0x20, 0xa7, 0x2c, 0x14, 0xdd, 0x14, 0xce, 0x5f, 0x45,
	0xdf, 0xe6, 0x1e, 0xe4, 0x63, 0x3e, 0xda, 0x81, 0x9c, 0xe4, 0x87, 0x35, 0x63, 0x2f, 0xb3, 0x5f,
	0xc0, 0x9a, 0x68, 0xe5, 0x61, 0x23, 0xe4, 0xb3, 0x60, 0x4c, 0xcd, 0x8f, 0x20, 0xa7, 0x22, 0x8e,
	0x6a, 0xb0, 0xe9, 0xdb, 0x42, 0xd0, 0xc0, 0x8b, 0x0a, 0x38, 0x26, 0xcd, 0x0a, 0x94, 0x56, 0x22,
	0x68, 0xfe, 0x23, 0x07, 0xa5, 0x15, 0x7f, 0x11, 0x83, 0xad, 0x4b, 0x2e, 0x94, 0x4f, 0x32, 0x80,
	0x91, 0x4f, 0xed, 0xc7, 0xc6, 0xaf, 0xd1, 0xd5, 0x60, 0xf2, 0xbb, 0x9b, 0xc2, 0xc5, 0xcb, 0x05,
	0x69, 0x0e, 0xa1, 0x30, 0x08, 0xf8, 0x35, 0x9b, 0x32, 0x31, 0x47, 0x1f, 0x43, 0xe9, 0x8a, 0x79,
	0x84, 0x5f, 0x59, 0x23, 0xea, 0xf0, 0x40, 0x5f, 0x9c, 0xc3, 0x5b, 0x9a, 0xd9, 0x52, 0x3c, 0xf4,
	0x11, 0x44, 0xb4, 0x65, 0x3b, 0x82, 0x06, 0xaa, 0xce, 0x73, 0xb8, 0xa8, 0x79, 0x87, 0x92, 0x65,
	0xfe, 0xc9, 0x80, 0x9d, 0x45, 0x8f, 0x1c, 0x92, 0x37, 0xb3, 0x50, 0x4c, 0xa9, 0x27, 0xd0, 0x10,
	0xaa, 0x0e, 0xbb, 0xa6, 0x32, 0x55, 0x49, 0xbf, 0x19, 0x0f, 0xe9, 0xb7, 0x6e, 0x0a, 0x57, 0x14,
	0xc2, 0x82, 0x85, 0xbe, 0x0b, 0x4f, 0x02, 0xea, 0xda, 0x82, 0xbd, 0xa3, 0xcb, 0xb8, 0xca, 0xae,
	0x6e, 0x0a, 0xa3, 0xf8, 0x70, 0xa1, 0xd2, 0xda, 0x02, 0xb0, 0x13, 0xab, 0xcc, 0xbf, 0xa7, 0xa1,
	0xb8, 0x14, 0x22, 0xf4, 0x02, 0x4a, 0x49, 0xf8, 0x55, 0xdb, 0x19, 0x8f, 0x6b, 0x3b, 0x1c, 0x67,
	0x51, 0x97, 0xc4, 0x2f, 0xa1, 0xe0, 0xc7, 0xa1, 0x8e, 0xa6, 0x43, 0xeb, 0xd1, 0x29, 0x4d, 0x92,
	0x86, 0x17, 0xa0, 0xe8, 0x37, 0x06, 0xbc, 0xb7, 0x88, 0x80, 0xb5, 0x70, 0x31, 0x1a, 0x1c, 0x5f,
	0x3c, 0xfa, 0xba, 0xdb, 0xb2, 0x89, 0x77, 0xdc, 0x5b, 0xb8, 0xad, 0x0d, 0xc8, 0xca, 0xc1, 0x12,
	0xff, 0xad, 0xef, 0xc2, 0xe6, 0x31, 0xa3, 0x2e, 0xe9, 0x91, 0x5b, 0x47, 0x7a, 0x1f, 0x8a, 0x03,
	0x3b, 0x10, 0x4c, 0x5e, 0xd5, 0x23, 0x68, 0x17, 0xc0, 0x0f, 0xf8, 0x1b, 0x3a, 0x16, 0x16, 0xd3,
	0x39, 0x2c, 0x28, 0x0f, 0x25, 0xa7, 0x47, 0x64, 0xf1, 0x49, 0xad, 0xd0, 0xb7, 0xc7, 0x54, 0x0a,
	0x64, 0x95, 0x40, 0x31, 0xe1, 0xf5, 0x48, 0xfd, 0x29, 0x94, 0x4f, 0x98, 0x47, 0x3a, 0xd7, 0x7e,
	0x40, 0xc3, 0x90, 0x71, 0xef, 0xd6, 0x6b, 0x7f, 0x6f, 0x40, 0xb5, 0x6d, 0x0b, 0x5b, 0xae, 0x36,
	0xda, 0xf7, 0xd5, 0x96, 0x42, 0x3f, 0x85, 0x2d, 0x3f, 0xb6, 0x45, 0xa2, 0xeb, 0xbc, 0x7f, 0x6b,
	0x5d, 0xd4, 0x96, 0x6c, 0xc7, 0x45, 0x7f, 0xc9, 0x91, 0xe7, 0x90, 0x7d, 0xcb, 0x3c, 0x12, 0x25,
	0xfa, 0xd3, 0x75, 0x18, 0xab, 0xe6, 0x62, 0xa5, 0x57, 0xff, 0x8b, 0x01, 0x4f, 0x8e, 0x5c, 0x3e,
	0x23, 0x43, 0xbd, 0x7c, 0x63, 0x1b, 0x31, 0xe4, 0x1d, 0xe6, 0x52, 0x2b, 0xa4, 0xf1, 0xac, 0xfb,
	0xfe, 0xda, 0xac, 0xfe, 0x37, 0x44, 0xe3, 0x98, 0xb9, 0x74, 0x48, 0x05, 0xde, 0x74, 0xf4, 0x07,
	0x6a, 0xc2, 0xce, 0x68, 0x2e, 0x68, 0x68, 0xb9, 0xb2, 0x8e, 0x2c, 0x9f, 0x06, 0x96, 0x3c, 0x52,
	0xd1, 0xcd, 0xe0, 0x6d, 0x75, 0x76, 0x2a, 0x8f, 0x06, 0x34, 0x90, 0xca, 0xe6, 0xfb, 0x32, 0xa7,
	0x5a, 0xb7, 0x0a, 0x99, 0x59, 0xe0, 0x46, 0xb1, 0x95, 0x9f, 0xf5, 0xbf, 0x1a, 0x50, 0x69, 0xb1,
	0xc9, 0x97, 0x33, 0x1a, 0xcc, 0x17, 0x56, 0x57, 0x84, 0x3d, 0x72, 0xa9, 0x15, 0x50, 0x87, 0x06,
	0xd4, 0x1b, 0xc7, 0x43, 0xed, 0x93, 0x75, 0xc6, 0xc7, 0x28, 0xe7, 0x52, 0x15, 0x97, 0x15, 0x02,
	0x8e, 0x01, 0x10, 0x06, 0xc4, 0x08, 0xf5, 0x04, 0x73, 0xe6, 0xcc, 0x9b, 0x58, 0x8e, 0x2c, 0xb2,
	0xb0, 0x96, 0x56, 0xbb, 0xe6, 0xe3, 0x75, 0xb0, 0x51, 0x39, 0xe2, 0xed, 0x25, 0x75, 0xc5, 0x0b,
	0xeb, 0xff, 0xce, 0x42, 0x29, 0x8a, 0xd6, 0x11, 0xf7, 0x1c, 0x36, 0x41, 0x3f, 0x87, 0x6d, 0x12,
	0xd7, 0x89, 0xc5, 0xb5, 0x3b, 0x51, 0x52, 0xbf, 0xbd, 0xee, 0x92, 0x9b, 0xc5, 0xd5, 0x4d, 0xe1,
	0x2a, 0xb9, 0x59, 0x70, 0x14, 0xde, 0x1b, 0xcb, 0x04, 0x59, 0xd1, 0x0b, 0x2b, 0xb9, 0x40, 0xf7,
	0x6b, 0xf3, 0x81, 0x99, 0xed, 0xa6, 0xf0, 0x93, 0xf1, 0x2d, 0x35, 0x73, 0x01, 0xdb, 0x23, 0x36,
	0xb1, 0x7e, 0x25, 0x63, 0x99, 0x5c, 0xa1, 0x17, 0xff, 0xb3, 0xfb, 0xc4, 0x7f, 0x01, 0x5f, 0x19,
	0xdd, 0x48, 0xac, 0x0d, 0x15, 0xf5, 0x88, 0xf3, 0x6d, 0xcf, 0x1a, 0xab, 0x88, 0xa9, 0x07, 0xd4,
	0x1d, 0xdb, 0x7e, 0x25, 0xc4, 0x8d, 0xf3, 0x08, 0x40, 0x93, 0xb8, 0x2c, 0x56, 0x68, 0xf3, 0x9f,
	0x06, 0x94, 0x57, 0x45, 0xd0, 0xe7, 0x00, 0xa1, 0xb0, 0x03, 0x61, 0x49, 0xd1, 0xa8, 0x92, 0xcc,
	0xc5, 0x85, 0xfa, 0x75, 0xa9, 0x71, 0xe5, 0xeb, 0x12, 0x17, 0x94, 0xb4, 0xa4, 0xd1, 0x67, 0x90,
	0xa7, 0x1e, 0xd1, 0x8a, 0xe9, 0x3b, 0x15, 0x37, 0xa9, 0x47, 0x94, 0xda, 0x2b, 0xf8, 0x84, 0x7a,
	0xaa, 0x82, 0xed, 0x99, 0xe0, 0x96, 0xcf, 0xfd, 0x99, 0xab, 0xde, 0xb6, 0x16, 0x77, 0xac, 0x9b,
	0x11, 0x90, 0xa1, 0xcd, 0xe3, 0xa7, 0x5a, 0xe1, 0x70, 0x26, 0xf8, 0x20, 0x11, 0xef, 0x3b, 0xab,
	0xae, 0x24, 0x63, 0xf2, 0xd7, 0x06, 0x14, 0xe3, 0x78, 0x9f, 0xd0, 0xf9, 0x57, 0xd2, 0x31, 0xbb,
	0x00, 0x01, 0xbf, 0xb2, 0xbc, 0xd9, 0x74, 0x14, 0x2d, 0xee, 0x0c, 0x2e, 0x04, 0xfc, 0xea, 0x4c,
	0x31, 0xea, 0x5f, 0x42, 0x65, 0xb9, 0xa8, 0xa4, 0x15, 0xef, 0x43, 0x41, 0x4d, 0x1b, 0xdf, 0x16,
	0x97, 0x51, 0x8f, 0xab, 0xf1, 0x33, 0xb0, 0xc5, 0xa5, 0x1c, 0xc6, 0x3a, 0x0b, 0xdc, 0x71, 0xe4,
	0x38, 0xd2, 0x80, 0x45, 0xc5, 0xeb, 0x2b, 0x56, 0xfd, 0x0c, 0xb6, 0x92, 0x46, 0x90, 0x78, 0xcf,
	0x01, 0x64, 0xcb, 0x89, 0xb9, 0xf5, 0x96, 0xce, 0x23, 0x87, 0x3e, 0x5c, 0x3b, 0x1b, 0xe9, 0x1c,
	0x17, 0xb4, 0xca, 0x09, 0x9d, 0xd7, 0xff, 0x65, 0x40, 0x46, 0xe2, 0xfc, 0x3f, 0x27, 0xf5, 0x8f,
	0x21, 0xab, 0xdc, 0xd3, 0x93, 0xe3, 0xd9, 0x1d, 0xd6, 0x34, 0xa4, 0xeb, 0x1d, 0x97, 0xaa, 0x0d,
	0xa8, 0x14, 0xcd, 0x73, 0xb9, 0xc2, 0x12, 0xa6, 0x5c, 0x37, 0x6a, 0xf2, 0x47, 0xeb, 0x46, 0x7e,
	0xa3, 0x2a, 0xa4, 0xa3, 0x75, 0x96, 0xe9, 0xa6, 0x70, 0x9a, 0x11, 0xb4, 0x13, 0x2d, 0x25, 0xd9,
	0xe9, 0x85, 0x6e, 0x4a, 0xaf, 0xa5, 0x56, 0x01, 0x36, 0x19, 0x51, 0x0f, 0xf3, 0xfa, 0x6f, 0xd3,
	0x50, 0xc0, 0x74, 0xcc, 0x03, 0x22, 0x1d, 0xbe, 0x80, 0xed, 0xd5, 0x49, 0xb1, 0x88, 0xdf, 0xb3,
	0xfb, 0x4e, 0x89, 0x13, 0x2a, 0xff, 0xb1, 0xa8, 0x8c, 0x6f, 0xe4, 0xb8, 0x0f, 0xa5, 0xc5, 0x84,
	0x93, 0xb0, 0xba, 0x2d, 0xf6, 0xef, 0x35, 0xdd, 0x34, 0xe6, 0x16, 0x59, 0x4e, 0xf2, 0x17, 0x50,
	0x5a, 0x8c, 0x1b, 0x09, 0x98, 0xb9, 0x3b, 0x3b, 0x4b, 0xa5, 0x2f, 0x9f, 0xa8, 0xa3, 0x05, 0x99,
	0x74, 0xc8, 0x25, 0x94, 0x56, 0xca, 0xfb, 0xc6, 0x5b, 0xc1, 0xb8, 0xf9, 0x56, 0xd8, 0x05, 0x50,
	0x66, 0xd1, 0xe5, 0xa7, 0x44, 0xc4, 0xe9, 0x11, 0xf4, 0x75, 0xc8, 0xeb, 0x06, 0x63, 0x44, 0x27,
	0x01, 0x6f, 0x2a, 0xba, 0x47, 0xea, 0x1d, 0xc8, 0x77, 0x54, 0xc9, 0xf5, 0x08, 0xfa, 0x1c, 0x72,
	0x6a, 0xb3, 0x44, 0xc1, 0xbe, 0xd7, 0x62, 0xd1, 0x1a, 0x9f, 0x0a, 0x80, 0xa5, 0x67, 0xaa, 0x09,
	0x5f, 0x3b, 0xed, 0x9d, 0x74, 0x4e, 0x7b, 0xdd, 0x7e, 0xbf, 0x6d, 0xbd, 0x38, 0x1b, 0x0e, 0x3a,
	0x47, 0xbd, 0xe3, 0x5e, 0xa7, 0x5d, 0x4d, 0xa1, 0x6d, 0x28, 0xbd, 0xec, 0xe0, 0x0b, 0xeb, 0xc5,
	0x99, 0x12, 0xb9, 0xa8, 0x1a, 0x68, 0x0b, 0xf2, 0x09, 0x95, 0x96, 0xd4, 0xa0, 0x3f, 0x1c, 0xf6,
	0x5a, 0xa7, 0x9d, 0x6a, 0x06, 0x01, 0x6c, 0x44, 0x27, 0x59, 0x54, 0x81, 0xa2, 0x52, 0x8d, 0x18,
	0xb9, 0xd6, 0x1f, 0x0c, 0xf8, 0x60, 0xcc, 0xa7, 0x6b, 0xec, 0x6c, 0x41, 0xdb, 0xf5, 0xa3, 0x02,
	0x18, 0x18, 0x3f, 0xfb, 0x51, 0x24, 0x39, 0xe1, 0xae, 0xed, 0x4d, 0x1a, 0x3c, 0x98, 0x34, 0x27,
	0xd4, 0x53, 0xc3, 0xb0, 0xa9, 0x8f, 0x6c, 0x9f, 0x85, 0xb7, 0xfd, 0x30, 0xf0, 0x43, 0xe2, 0xfa,
	0x7f, 0x4c, 0xd7, 0x7e, 0xa2, 0xf5, 0x55, 0xa9, 0x35, 0xda, 0xae, 0xdf, 0x78, 0x79, 0xd0, 0x92,
	0xc7, 0x7f, 0x8b, 0x8f, 0x5e, 0xab, 0xa3, 0xd7, 0x6d, 0xd7, 0x7f, 0xfd, 0x52, 0x6b, 0x8e, 0x36,
	0x14, 0xfe, 0xf7, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x78, 0x92, 0xfd, 0x26, 0x77, 0x10, 0x00,
	0x00,
}
